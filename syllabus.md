# Syllabus (Clean Extract)

## Week 0 — Day -6

### Content

Prework - 
Skill 0.1: Familiarizarse con la plataforma de 4Geeks
Skill 0.2: Comprender cómo funciona internet

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -6

**Status:** Aprobado

### Teoría

+ Introducción a 4Geeks Academy
  - Importancia del prework (crear nuevo)
  - Intro a la plataforma de 4Geeks.com (crear nuevo)
  - Breve intro a Github como perfil profesional en tecnología
    -- Importancia de conectar la cuenta de Github con la plataforma de 4Geeks.com

+ Herramientas a tu disposición en 4Geeks Academy
  - Intro a Slack
  - ¿Qué es LearnPack?
  - ¿Qué es Rigobot?
  - ¿Qué es Github Codespaces?

+ Consejos para estudiar con éxito en 4Geeks
  - ¿Cómo aprovechar al máximo el curso?
  - ¿Cómo pedir ayuda?




+ La Internet
  - ¿Qué es internet?
  - Funcionamiento: HTTP y sus verbos (GET, POST, PUT/PATCH, DELETE), Cliente - Servidor
  - Navegadores
  - Cómo funciona una web: frontend, backend - APIs, bases de datos, llamadas a APIs (HTTP)
  - Cómo se transmite una solicitud por Internet

### Thinking Framework

#### Thinking Development
- Aprender cómo aprender en 4Geeks
- Conocer los componentes principales del proceso de aprendizaje en 4Geeks
- Conocer los medios y mecanismos para solicitar y obtener ayuda en 4Geeks
- Saber entregar proyectos en 4Geeks usando Git y Github
- Concientizar la necesidad del hábito de leer y atender a los detalles 

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
- No pedir ayuda
- No investigar
- Esperar a que todo me lo expliquen
- No usar los canales de comunicación

#### Constraints & Limitations
- No IA

## Week 0 — Day -5

### Content

Prework - 
Skill 0.3: Conocer los fundamentos de HTML, CSS y Git para entregar un primer proyecto

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -5

**Status:** Aprobado

### Teoría

+ Introducción a HTML y CSS (Se dejará lo actual)

+ ¿Cómo entregar tus proyectos en 4Geeks? 
  (Esto ya existe pero requiere revisión: mejorar organización) 
  - Breve reseña sobre GitHub y Git, de forma poco técnica
  - (Esto no existe) Esenciales de Github y Git para entregar proyectos
    -- git add, git commit, git push

### Thinking Framework

#### Thinking Development
- Entender flujos (http es movimiento de información y hay un objetivo para ese movimiento, un flujo). Esto incluye , git, internet, algoritmos, etc.  
- Comprender los principales componentes de la comunicación en Internet
- Conocer los principales elementos de un sitio web
- Familiarizarse con algunos de los principales conceptos del programa de estudios

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 0 — Day -5

**Status:** Aprobado

### Proyecto

  - Postcard (entregada en un repo)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -4 y -3

### Content

Prework - 
Skill 0.4: Conocer y aplicar los fundamentos de la programación

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -4 y -3

**Status:** Aprobado

### Teoría

+ Introducción a la programación (Javascript) (Referencia rápida a los conceptos)
  - Pensamiento lógico-matemático
  - Algoritmos
  - Variables
  - Condiciones
  - Bucles
  - Cómo representar listados en JavaScript (Arrays)
  - Cómo objetos en JavaScript (Literal Objects)

### Thinking Framework

#### Thinking Development
- Pensamiento lógico - matemático, algoritmos. 
- Concientizar la necesidad del hábito de leer y atender a los detalles 
- Reconocer la importancia de desarrollar la autonomía en la resolución de problemas

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- Plantear la solución antes que el código
- Divide y venceras. Dividir un problema grande en subproblemas más pequeños del mismo tipo, resolver cada uno, y luego combinar las soluciones.
- Clean code

#### Anti-patterns
Algoritmos: 
- Fijación en la Sintaxis: Centrarse únicamente en recordar la sintaxis del lenguaje de programación antes de tener una lógica clara.
- Pensamiento lineal: Intentar escribir toda la solución de una vez, de principio a fin, sin planificación.
- Aplicar correacciones por reacción a lo que aparece en la consola y no por análisis del código
- Test de Único Caso. Probar el algoritmo solo con el caso de ejemplo proporcionado, sin considerar casos límite (vacíos, negativos, máximos) o casos de borde.

#### Constraints & Limitations
- No IA

## Week 0 — Day -4 y -3

**Status:** Aprobado

### Práctica

  - Beginner JS (nuevo) 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -2

### Content

Prework - 
Skill 0.5: Comprender cómo funciona la IA Generativa y los principales modelos z
Skill 0.6: Conocer los distintos formatos para comunicarse con la IA Generativa

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -2

**Status:** Aprobado

### Teoría

+ Introducción a la IA generativa
  - ¿Qué es un LLM?
  - ¿Y cómo funciona la IA?
  - ¿Cuáles son las principales opciones (OpenAI ChatGPT, Google Gemini, Anthropic Claude, xAI Grok, Mistral LeChat...)?
  - Diferencias: Ventajas y desventajas entre modelos

+ Hablar en el lenguaje de la IA:
  - Markdown
  - JSON
  - YML
  - TOON  (nuevo formato, potencial de convertirse en tendencia)

### Thinking Framework

#### Thinking Development
- Entender cómo funciona los modelos de IA generativa
- Desarrollar criterio para escoger entre un modelo u otro
- Comprender cómo desarrollar un buen contexto para la IA
- Reconocer la importancia de desarrollar la autonomía en la resolución de problemas

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
- Tratar a todas las IAs por igual
- Escribir sin estructura ni formato

#### Constraints & Limitations
- No IA

## Week 0 — Day -2

**Status:** Aprobado

### Práctica

  - Escribir una configuración en YML y JSON

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1

### Content

Prework - 
Skill 0.7: Conocer qué son los Coding Agents y cómo funcionan
Skill 0.8: Conocer los fundamentos de la AI Engineering

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1

**Status:** Aprobado

### Teoría

+ Using Coding agents 
  - ¿Cómo funciona la IA en desarrollo?
  - Configuración básica de Coding Agent en Github Codespaces
  - Herramientas más conocidas: https://agents.4geeks.com/
  - Using LLMs
  - Token consumption, pricing, parameters

+ Fundamentos del AI Engineer
  - Programación asistida con IA
  - Human in the loop / Humanos en el proceso
  - Camino de menor resistencia

### Thinking Framework

#### Thinking Development
- Entender cómo funcionan los Coding Agents
- Desarrollar criterio para escoger entre un modelo u otro
- Comprender cómo desarrollar un buen contexto para la IA
- Concientizar la necesidad del hábito de leer y atender a los detalles 
- Reconocer la importancia de desarrollar la autonomía en la resolución de problemas

#### Best Practices
- Iterar vs crear de nuevo: vibecoding manifest
https://vibemanifesto.org/

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1

**Status:** Aprobado

### Proyecto

+ Proyecto final: Excuse generator para imprimir por consola
  1. Pedir a Copilot que cree un fichero JS
  2. Pedir a Copilot que cree un array de quién
  3. Pedir a Copilot que cree un array de acción
  4. Pedir a Copilot que cree un array de qué
  5. Pedir a Copilot que cree un array de cuándo
  6. Pedir a Copilot que genere una línea de código para obtener un valor aleatorio del array quién, otro valor aleatorio del array acción y otro del array qué y el array cuándo
  7. Pedir a Copilot que concatene todos los valores obtenidos con un espacio en blanco de por medio y lo inserte en una variable
  8. Pedir a Copilot que inserte un console.log para imprimir el valor de la variable en la terminal.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No se imprime por html para reducir la complejidad con el tema del DOM, que los estudiantes se ponen a investigar porque no entienden por qué esos comandos

## Week 1 — Day 1

### Content

Skill 1: Desarrollar interfaces sencillas con HTML y CSS cumpliendo con normas de accesibilidad y principios de SEO/GEO

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 1

**Status:** Approved

### Content

- Se dan 30 minutos de repaso de prework
  - Coding Agents
  - Fundamentos de AI Software Engineer

> Teoría (30 minutos): 
  + HTML
    - Principales etiquetas
    - HTML semántico y contextual
    - Buenas prácticas
  + CSS
    - Flexbox
    - DRY en CSS
    - Selectores avanzados
    - Buenas prácticas
  + Accesibilidad web
    - Principios
    - Etiquetas principales (aria-label y role)
    - Principales problemas de accesibilidad
  + SEO y GEO 
    - Schema.org

### Thinking Framework

#### Thinking Development
- Reconocer una interfaz y saber rapidamente en que cajas se va a dividir.
- Poder seleccionar un elemento del DOM

#### Best Practices
- Uso de tags generales ✅
- DRY ⚠️
- Uso de html contextual (section, footer, header, head, body, atributo 'alt') ⚠️
- SEO/GEO (schema org) ⚠️
- Accesabilidad (principios, aria-label, alt...)⚠️

#### Patterns
-Flexbox
-Semantic HTML
-BEM Methodology
-Mobile First

#### Anti-patterns
- display: inline-block
- float

#### Constraints & Limitations
- No hay backend
- No hay javascript
- Especificamente pedirle a la ia que no queremos plantilla
- Usar un modelo viejo como sonnet 3.5

## Week 1 — Day 1

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1: Un website para mostrar el talento de tu amigo artista
   
   La entrega debe tener un markdown llamado PROMPTS.md con todos los prompts utilizados para el resultado

   Indicar los requisitos (HTML, CSS, Accesibilidad y Schema.org)


> Instrucciones al profesor:
  - Este curso solo puede tener HTML y CSS, incluyendo etiquetas de Accesibilidad 
  - Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su resultado
  - HTML y CSS deben quedar en archivos separados.
  - Crear un único documento HTML con distintas secciones: Bienvenida, sobre mí, mi trabajo y contacto
  - No permitir que se use un único prompt para hacer todo el ejercicio
  - Asegurar el cumplimiento, con mejores prácticas de código y de diseño, etc.
  
> Propuesta para guiar el ejercicio:
    - Se deben incorporar elementos poco a poco (el body, luego una barra superior, luego un logo a la izquierda y una lista de enlaces a la derecha)

  1. Se pide (de forma vaga, sin detalle, aunque limitado para que no resuelva todo el proyecto) a la IA que haga una web personal de AI Engineer con solo HTML y CSS.  
  2. Se revisa el código.
  3. Se pide que haga una nueva versión, refinando la solicitud, y se le pasa pasa la foto.
  4. Se revisa el código resultante.
  5. Se contrasta con lighthouse (disponible en crhome y brave de forma nativa). Se pulen los puntos bajos 
  6. Se revisa el código "final"

  7. Se analizan las diferencias entre las solicitudes y entre los resultados

  + Actividad extra (en caso de que el proyecto salga rápido):
    - Hacer que la vista sea un Feed de Instagram, repitiendo la estructura del post con distintas imágenes y texto. 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 2

### Content

Skill 2: Desarrollar interfaces complejas utilizando librerías de CSS en lugar de CSS y reconociendo los componentes más comunes utilizados en un website 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 2

**Status:** Approved

### Teoría

  + Web app layouts
    - ¿Qué es el layout? 
    - Formas de navegación: Sidebar, topbar, bottombar, etc...
    - Todos los tipos de diagramación de vistas y contenido en una sola página
    - Introducción al diseño compuesto (old atomic desing) aplicado a web: átomos, moléculas, organismos, plantillas, páginas

  + Componentes web
    - Elementos típicos para representar tus datos (card, modal, toggle, dropdown)
    - Listados de elementos: Tablas, acordión, lista de cards, cards desplegables, widget box.

  + Diseño responsivo
    - ¿Qué es el diseño responsivo?
    - ¿Por qué es importante que el contenido se adapte a cada tipo de pantalla?
    - Principales pantallas: Móvil, Tablet, Portátil, Monitor o TV
    - ¿Cómo se gestiona el diseño responsivo? media queries vs bibliotecas CSS (referencia genérica, se puede usar ejemplo con Tailwind)
    - Mobile-first design


  + Tailwind
    - Ask Rigobot: ¿Qué es un CDN?
    - Ventajas de usar una biblioteca de estilos
    - Situaciones comunes: ir sobre casos de uso (spacing: padding y margin, sizing: width, height..., overflow y scrolling, posicionamiento de elementos)

### Thinking Framework

#### Thinking Development
- Saber identificar componentes en función del diseño (Pensar en interfaces de usuario con piezas reutilizables) 
- compositional thinking: la idea es que el desarrollador vaya del macro al micro, empezando por el componente más externo hasta el más específico
- Iteración top-bottom con IA: de la estructura principal a las características, terminando con colores y tipografías
- Describir conceptualmente y no visualmente
- Reconocer componentes en una interfaz
- Identificar qué elementos cambiar según el dispositivo

#### Best Practices
- Using CDN
- Style normalization (https://tailwindcss.com/docs/preflight)
- Responsive Breakspoints at least 3 devices (phone, portrait tablet, desktop)
- Mobile-first design
- Rows vs Columns
- Flex vs GRID ⚠️
- Using tailwing utility classes

#### Patterns
- Componentes reutilizables
- Section based architecture
- Slot and layout pattern
- Prompt as pattern: Generate a [section_type] using [framework].
It should include [key elements]. Follow the [theme] and use Tailwind utilities for spacing and alignment.
- Mobile pattern

#### Anti-patterns
- Pixel based thinking (e.g.: button de 30px)
- Single prompt page generation
- Ignorar la jerarquía de los componentes
- Overstyling / Estilos excesivos
- Hacer componentes muy específicos en lugar de reutilizar anteriores

#### Constraints & Limitations
- Usar un modelo viejo como sonnet 3.5

## Week 1 — Day 2

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto: Mi primer dashboard para mostrar datos
 
  1. Se pide a la IA que haga un dashboard con Tailwind, solo HTML y CSS
  2. Se revisa el código
  3. Si no resulta satisfactorio el resultado, se refinan detalles con la IA (describiendo las dos vistas en detalle)
  4. Se revisa el resultado y se evalúa el cumplimiento de mejores prácticas y patrones en el código
  5. Pedirle a la IA que haga que desde la barra de navegación se pueda cambiar el tipo de visualización

  + Actividades extra:
    - Agregar efectos visuales avanzados y animaciones

> Instrucciones al profesor:
  - Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su resultado

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- Usar Tailwind CSS sin bibliotecas de componentes como ShadCN

## Week 1 — Day 3

### Content

Skill 3: Desarrollar formularios complejos pero con interacciones sencillas, utilizando bibliotectas de CSS + JS muy sencillo

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 3

**Status:** Approved

### Teoría

  + Formularios
    - Etiquetas principales
      - Inputs de texto (text, email, autocomplete)
      - Inputs de selección: radiobutton y checkbox
      - Otros inputs (numéricos, fechas...)
      - Textarea
      - Selects (y options)
      - Botones: input=submit vs button
    - Identificando y agrupando campos: Labels, placeholders y fieldgroups
    - Validaciones en formularios con navegador
    - Casos especiales: required, disabled, read-only
    - Casos de uso más comunes en formularios (login, contacto, búsqueda, registros, compra)

  + Tailwind en formularios
    - Form layouts (login, inline, grid)
    - Elementos típicos para representar en tus formularios (alerts, form, modal, dropdown, switch, toggle groups)
    - Situaciones comunes Tailwind en forms (spacing y sizing, señalización de errores)

  + Flujos con formularios
    - Campos condicionados / interdependientes
    - Adaptive stepped forms
    - Formularios compuestos ("Modal para Creación de Dependencia")
    - Validaciones avanzadas (JS para formularios)

  + Buenas prácticas en formularios / Formularios efectivos (pocos datos)
    - Campos innecesarios:
      -- Por redundancia (fecha inicio + fecha fin + duración)
      -- Por pertinencia (dirección de casa para crear una cuenta de usuario)
      -- Puede solicitarse en otro momento (pedir datos fiscales para crear una cuenta de usuario)

### Thinking Framework

#### Thinking Development
- Identificar que informacion precisas
- Cosas que no tienes que aprender en este punto (entrañas de JS en la validación, condiciones de dependencia entre los formularios)

#### Best Practices
- Uso del correcto input type
- Uso del label y el atributo for
- Agrupar campos con un mismo propósito (fieldset y legend)
- Validación por defecto y campos requeridos
- Diagramación de formularios
- Consistencia Visual

#### Patterns
- utility-first
- Validación inmediata
Patrones de diseño:
- Componentes de Campos de Entrada
- Contenedor de Grupos de Campos
- Mensajes de Alerta/Feedback

#### Anti-patterns
- no label / placeholder as a label / label confuso
- input type text para todo
- Campos innecesarios
- Formularios largos
- Ocultar los errores hasta el final
- No responsive

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 3

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto (Hito 1): Web pública de "mi empresa"
 1. Pide a la IA que haga la landing page de tu producto. Ten en cuenta las características descritas arriba.
 2. Revisa el contenido generado y su código.
 3. Solicitar a la IA un documento nuevo con un formulario de postulación para probar el futuro producto.
 4. El formulario deberá tener al menos un campo nombre, un campo correo, un campo fecha de nacimiento (para verificar si es un adulto) y un campo de texto largo para la motivación de la postulación.
 5. Se pueden agregar campos opcionales como ¿Cuánto pagarías por este producto? (campo numérico)
 6. Revisar el resultado y las buenas prácticas empleadas en el código.
 7. Después de revisar, hazle las observaciones que consideres pertinentes para que la IA las corrija
 8. Agrega validación de campos con VanillaJS para cada formulario (aunque no sepas hacerlo, la IA lo hará por ti si se lo explicas adecuadamente)
 9. Verifica que las validaciones funcionan correctamente y que los mensajes de error tienen estilos adecuados
 10. Agregar botón secundario para borrar los datos del formulario


> Instrucciones al profesor:
  - Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su resultado
  - Debe tener 2 "vistas" Una con el portafolio + el contacto y otra con el formulario de cotización. 
  - Se deberá hacer un repositorio nuevo, no reutilizar el del dia 1, pueden reutilizar los prompts

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 4

### Content

Skill 4: Utilizar la línea de comando para interacciones basicas en el dia a dia en la vida de un desarrollador

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 4

**Status:** Approved

### Teoría

  + Sistema de archivos (Jerarquía)
    - Rutas relativas vs Rutas absolutas
    - Entry point
  + Command Line / Terminal
    - 10 comandos más usados por un programador (+ 1: incluir grep)
    - Editores de archivos más comunes: vi, nano (comandos principales: salida, edición y escritura)
    - Conexiones SSH

### Thinking Framework

#### Thinking Development
- Comprensión del sistema de archivos y su jerarquía
- ¿Dónde estoy cuando estoy en la Terminal?
- Cómo referenciar rutas desde mi ubicación
- Cómo ubicar un proceso en la estructura
- La raíz de un proceso no es la raíz del proyecto. Es la ruta del entry file (entrypoint)

#### Best Practices
- Uso de rutas absolutas antes que relativas
- Evaluar dónde estoy antes de intentar moverme en el sistema de archivos

#### Patterns
- navegación por directorios (\(cd\), \(pwd\))
- la gestión de archivos (\(ls\), \(cp\), \(mv\), \(rm\))
- la ejecución de comandos para interactuar con el sistema operativo

#### Anti-patterns
- Trabajar en modo root (superuser / admin)

#### Constraints & Limitations
- No IA
- No se creará un Shell Script, pero se les explicará en qué consisten

## Week 2 — Day 4

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1: exercise-command-line-challenge (reemplazar https://cmdchallenge.com/)

> Proyecto 2 (a evaluar viabilidad):
  - ¿Conectarse a un servidor remoto por SSH y encontrar un texto?
  - Pedir a la IA que genere los comandos por nosotros

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 2 — Day 5

### Content

Skill 5: Git + Github => Aprender a trabajar colaborar y comandar una IA de forma eficiente y con bajo riesgo

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 5

**Status:** Approved

### Teoría

  + Git para devs
    - Cómo funciona
    - Cómo saber dónde estoy (concepto de HEAD)
    - Principales comandos (git status, git add, git commit, git pull, git push, git remote)
    - Algunos comandos avanzados (git merge, git log [y --stat], git revert,  git stash, git reset)
    - Gestión de cambios: Línea de comandos vs Interfaz del editor (IDE) vs hechos por IA
    - Ramas (git branch, concepto de HEAD)
    - Gitflow simplificado (main, dev, feature/, bugfix/) <--- Establecer lineamientos de base para homologar entre profesores y evitar "ramas personales"
    - git switch vs git checkout [y -b]
    - git merge vs git rebase
    - Buenas prácticas en Git
  + Github
    - ¿Qué es Github? 
    - Issues
    - Forks vs Templates
    - Pull Requests (entre ramas y entre repos)
    - Buenas prácticas en Github
  

### Thinking Framework

#### Thinking Development
- Relacionar commits con características o funcionalidades
- Identificar los principales comandos de Git y su uso en el IDE
- Saber dónde estoy en un proyecto git
- Cómo moverme entre ramas
- Incorporar el uso de PR como mecanismo para incorporar funcionalidades/características por ramas
- Cómo colaborar o contribuir de forma organizada
- Como deshacer o revertir cambios

#### Best Practices
- Selección de archivos de un commit
- Una característica (vista, en este caso), una rama
- Hacer PR
- Mantener limpieza de ramas

#### Patterns
- Git por línea de comandos
- Git por IDE
- Gitflow (simplificado: trabajo con ramas principales y nomenclatura base)
- Partir de un core (main) y hacer PRs al core
- Configuraciones y claves fuera del repositorio
- ¿¿¿Fusionar ramas muy antiguas sin git rebase???
- ¿¿¿ Git rebase (es un patrón pero puede agregar complejidad) ???

#### Anti-patterns
- Uso del git add . o añadir todo al commit siempre 
- Trabajo directo en main
- No describir adecuadamente los commits
- Commits muy grandes
- --force
- Subir los .env y configuraciones al proyecto
- PR sin revisiones
- Ignorar las peticiones de PR Alejandro Sanchez xD

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 5

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto colaborativo en pareja (Equipo + IA + Git): maquetación de una tienda estática colaborativa con IA (Solo HTML y Tailwind)
  1. Preguntar a la IA ¿Qué elementos básicos debe tener la maqueta de una tienda en línea?
  2. Validar la respuesta de la IA y analizar se se adecúa a lo que se busca
  3. Distribuir tareas por características/vistas (crear el repo común y actividades)
  4. Desarrollar características en ramas
  5. Unificar desarrollos en rama principal
  6. Conectar vistas (commits y merges adicionales)
 
Debe contener todo lo que se ha visto anteriormente (HTML semántico, Tailwind, Schema.org, diseño responsivo) y conformarse por 5 vistas
- Home (con una barra de navegación, un Hero, listado de productos nuevos, listado de productos más comprados, footer)
- Catálogo (listado de productos y barra de filtros)
- Producto (Foto de producto, detalles de producto, precio y descripción)
- Carrito (vista completa del contenido de un carrito con sus productos, la totalización y botón de comprar)
- Formulario de pago (datos personales, dirección de entrega y datos de tarjeta)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- Solo HTML y Tailwind
- Nada de React.
- Puede haber alguna acción con JS

## Week 2 — Day 6

### Content

Skill 6: Representar y estructurar de forma determinista la lógica de un sistema usando flujos secuenciales con contextos variables 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 6

**Status:** Approved

### Teoría

  + ¿Qué es la programación? -> Darle instrucciones a una máquina
   - Pensamiento Algorítmico -> Escribir en pseudocódigo.
   - Variables 
   - Direcciones de memoria
   - Tipos de datos básicos o primitivos (character, integer, float, boolean)
   - Tipos de datos estructurados o complejos (mención superficial a cadenas de texto, colecciones (arrays) y objetos)
   - Operadores (aritméticos, de asignación, de comparación y lógicos) : versión simple de cada uno. 

  + Dominando el Flujo del Programa (Lógica de Programación y Control de Ejecución):
   - Control de flujo (condicionales) - Control flow
     -- Identificación de casos borde/límite
   - Estado del flujo - State flow
   - Conceptos de iteración y bucles (for, while) 
   - Scope / Contexto
   - Flujos anidados
   - Flujos reutilizables (introduccion teórica a "funciones")

### Thinking Framework

#### Thinking Development
- Pensamiento lógico / matemático.
- Ir de los específico a lo general: comenzar por las excepciones al construir el algoritmo.
- Saber diferenciar entre el crontrol flow y el state flow
- Saber predecir state flow (ejecución en frio)
- Identificar y evaluar los casos borde/límite de un problema
- Reducir los condicionales al mínimo: bifurcar es agregar complejidad
- Identificar el uso del concepto que se esta aprendiendo ( que el alumno comprenda "cuanto necesita entender" de un concepto para poder avanzar, por ejemplo para usar un taladro para colgar un cuadro no necesito comprender la electronica del mismo mientras que si lo que busco es mejorar el taladro si que requira comprender sus componentes y funcionamiento interno para esa tarea)
- Plantear soluciones en tu idioma nativo primero, luego pseudocódigo
- Comprender el próposito para alcanzar el objetivo
- Comprender que no necesito conocer y dominar todo para plantear una solución en pasos y procesos (pueden existir cajas negras) 

#### Best Practices
Analogías con el mundo real

#### Patterns
El Patrón "Sándwich" (IPO: Input-Process-Output)
Es la estructura fundamental. Todo algoritmo debe tener tres fases claras.
-Entrada (Input): Definir qué necesito (ingredientes). Inicializar variables (Contador = 0).
-Proceso: La lógica, cálculos y bucles.
-Salida (Output): Mostrar el resultado o devolver el valor.

El Patrón de "Salida Única" (Single Exit Point)
Idealmente, un algoritmo o una sub-rutina debe tener un solo punto de inicio y un solo punto de fin.

El Patrón del "Centinela" (Para Bucles)
Al diseñar bucles mientras (while) o repetir (for), debe existir una condición clara de parada controlada por una variable.

Modularización (Sub-procesos)
Cuando un diagrama de flujo se hace muy largo, se debe colapsar una sección lógica en un "Proceso Predefinido" (generalmente un rectángulo con barras laterales).

#### Anti-patterns
El Flujo Espagueti (Unstructured Jumps)
El uso indiscriminado de flechas que cruzan todo el diagrama para volver a un punto arbitrario anterior (el equivalente al temido GOTO).

El "Paso Milagro" (The Miracle Step)
Un paso en el algoritmo que es demasiado ambiguo o complejo para ser una sola instrucción.

El Bucle Infinito Visual (The Black Hole)
Un ciclo donde las flechas de "No" o "Sí" vuelven al inicio del ciclo, pero ninguna acción dentro del ciclo cambia la condición.

Código Muerto (Unreachable Code)
Partes del diagrama o algoritmo a las que es imposible llegar porque la lógica anterior las excluye.

#### Constraints & Limitations
- No IA

## Week 2 — Day 6

**Status:** Proyecto
pendiente
aprobación

### Práctica

  - Learnpacks Con múltiples retos de diseños de flujo y "state machine" (ejercicio tipo los del Command Line) para validar que lo hagan correctamente

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 7

### Content

Skill 7.1: Entender los fundamentos de TypeScript, su sintaxis y cómo aplicar el concepto de algoritmos en Typescript

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 7

**Status:** Approved

### Content

> Teoría 
  + Fundamentos de Javascript y Typescript: 
    - ¿Qué es JavaScript?
    - ¿Qué es TypeScript?
      -- Relación entre JS y TS (JS vs TS)
      -- ¿Cómo funciona TS? 
    - ¿Cómo se escribe código en TS?
      -- ¿Qué es la sintaxis?
      -- Reglas principales de TS
    - ¿Para qué sirve el console.log()?
    - Variables (const, let, var)

  + Tipos de datos y operadores básicos de TS: 
    - Tipos de Datos primitivos (number, boolean, string, symbol, null, undefined) 
    - Operadores en JavaScript (aritméticos, asignación, comparación, lógicos) : versión simple de cada uno. 
  
  + Control de flujos en JavaScript y Typescript
    - Flujos simples: Condicionales (if, else if, else, switch)
    - Flujos repetitivos: Bucles 
      -- for
      -- while
      -- for..in, for..of y do-while como referencias adicionales
      -- interruptores de flujo: break (para cortar la ejecución) y continue (para saltar esta iteración)
      -- Bucles anidados

### Thinking Framework

#### Thinking Development
- Convertir soluciones de pseudocódigo a la sintaxis del lenguaje.
 
- Aprender a investigar siempre que sea necesario. (memorizar no es una habilidad a desarrollar, se dará con la práctica) 

- Identificar cuándo se hace uso de una palabra reservada. 

- Aprender a identificar tipos de datos por su valor (su composicion). 

- Comprender las diferencias de los tipos de datos

- Identificar los casos de uso de cada tipo de dato

- Escribir una instrucción por línea. Usar punto y coma ; (aunque sea opcional, para enseñar disciplina).

#### Best Practices
Escribe el codigo, no lo copies

Identacion 

#### Patterns
- lowerCamelCase

- Logs Etiquetados: console.log("El valor de x es:", x)

- Const-First: Usar const por defecto, y let solo si el valor va a cambiar.

- Nombres Semánticos

- Igualdad Estricta

#### Anti-patterns
- Buscar la sintaxis perfecta. 

- Usar código mágico (copiar y pegar, no tener concimiento de lo que hace código)

- Inconsistencia en la sintaxis (no mantener decisiones anteriores en estructura, patrones, etc)

- Crear bucles infinitos

- Condiciones kilométricas 

- Arrow Code / Hadouken: if dentro de if dentro de if... formando una flecha a la derecha. 

#### Constraints & Limitations
- No IA

## Week 3 — Day 7

**Status:** Approved

### Content

> Prácticas:
  - Learnpack co varios códigos generados por IA para revisar y corregir o aprobar.
  - Learnpack (aparte del Beginner TS) orientado a condicionales y flujos llegando a una mayor dificultad que el Beginner JS (aquí podrían estar Beatles, Bottles of milk...)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 8

### Content

Skill 7.2: Aprender a nombrar/etiquetar los flujos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 8

**Status:** Approved

### Content

> Teoría 
  
  + Funciones en Javascript y Typescript
    - ¿Qué es un bloque de código?
    - Dar nombre a un bloque de código (creando una función)
    - Párametros (cómo pasar valores a una función)   
    - ¿Cómo devuelve valores una función? (funcionamiento del return y especificación del tipo de dato devuelto) 
    - Métodos vs funciones vs procedimientos (funciones que devuelven valor y funciones que no)
    - Métodos y funciones para trabajar con datos primitivos (string, number, etc)  

### Thinking Framework

#### Thinking Development
- Desarrollar un flujo si hay un objetivo solo, que son: 
 -- Mutar un valor de un proceso global
 -- obtener un valor y retornarlo
 
- Reconocer los valores que necesita mi funcion para lograr su objetivo

- Reconocer el tipo de funcion que requiero

- Mantener el principio de responsabilidad única 

#### Best Practices
- Escribir funciones en sus diferentes versiones
- Leer un código existente y reescribirlo en funciones
Console.log tu mejor amigo
Usar variables en vez "código cableado" 
Leer errores

#### Patterns
- DRY
- Return Early (Cláusulas de Guarda)
- Funciones Puras (Concepto): La función debe trabajar solo con lo que recibe en sus parámetros ((a, b)).
- Single Responsibility (SOLID): Una función hace UNA sola cosa y la hace bien (calcularIva()).

#### Anti-patterns
-God Function: Una función que calcula, imprime, guarda y valida.

- Dependencia Global: Usar variables que están fuera de la función sin pasarlas como argumentos.

#### Constraints & Limitations
- No IA

## Week 3 — Day 8

**Status:** Approved

### Content

> Sólo práctica:
  - Learnpack con varios códigos con funciones (con y sin parámetros, con y sin devolución de resultado) y sus llamadas generados por IA para revisar y corregir o aprobar.
  - Mastering JS (adecuarlo explicando que es un learnpack que usará a lo largo de todo el contenido de JS y que conforme avancen las clases irá aprendiendo a solucionar más problemas)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 9

### Content

Skill 8.1: Manipular datos estructurados de tipo colecciones: transformándolas, recorriendolas y buscando informacion de forma óptima

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 9

**Status:** Approved

### Teoría

  + Arreglos/Colecciones de elementos (arrays)
    - ¿Qué es un array?
    - ¿Cómo definir un array? (Sintaxis)
    - ¿Cómo acceder a posiciones en un array? ¿Cómo agregarlas o eliminarlas?
    - ¿Cómo recorrer un array? (for o while)
    - Principales métodos para recorrer arrays
    - ¿Qué es una matriz? (Arrays de arrays)
    - ¿Cómo acceder a las posiciones de una matriz? ¿Cómo agregar o eliminar posiciones?
    - ¿Cómo recorrer una matriz?
    
  + Ordenamiento y búsqueda en arrays
    - Ordenamiento de arrays con .sort() (con Botón Ask to Rigobot "What are the Sorting Algorithms")
    - Búsqueda lineal o secuencial en un array (Arrays desordenados - Métodos .find() e .includes())
    - Búsqueda eficiente en un array ordenado (Algoritmo de búsqueda binaria)
    - Búsqueda en matrices
 

### Thinking Framework

#### Thinking Development
- Defnir y gestionar un array
- Definir y gestionar matrices
- Diferenciar arrays y matrices
- Entender cuando un elemento es iterable
- Buscar elementos en un array
- Buscar elementos en una matriz
- Ordenar arrays

#### Best Practices
-  Aprender a gestionar arrays con bucles y con métodos del lenguaje.

- No memorizar.  Investiga cada que necesites usar un método

#### Patterns
- Reasignación Explícita: texto = texto.toUpperCase() o guardar en nueva variable: const grito = texto.toUpperCase().

- Homogeneidad en arrays/colección

- Usar sintaxis literal > [ ]

- Iterar copia o Inversa

#### Anti-patterns
- Chaining Infinito: Encadenar 5 métodos sin saber qué devuelve cada uno: str.split().reverse().join()....

- El Cajón de Sastre: listas con varios tipos de datos.

- new Array() 

- Mutación durante iteración 

-Hardcoding del límite (en bucles for para arrays)

- Acceso:        Usar array[100] sin verificar el tamaño. Devuelve undefined y rompe operaciones posteriores.

#### Constraints & Limitations
- No IA

## Week 3 — Day 9

**Status:** Proyecto
pendiente
aprobación

### Práctica

  - Mastering JS (ejercicios con Arrays)

> Proyecto 1: Gestor de butacas de cine
  - Crear una matriz de butacas con ocupadas (1) y libres (0)
  - Visualizar la sala imprimiendo la matriz con L (libre) y X (ocupado)
  - Poder reservar un asiento (marcarlo con 1)
  - Contar cuántas butacas están llenas y cuántas están vacías
  + Actividad extra: 
    - Buscar asientos contiguos para parejas (dos personas)
    - Darle a la IA el código desarrollado y pedirle que genere una interfaz para usarlo en modo web

> Proyecto 2: Almacén inteligente:
  - Crear un listado de ids de paquetes que siempre esté ordenado
  - Agregar nuevos paquetes (y reordenar)
  - Verificar si un paquetes está en el listado por búsqueda binaria
  + Actividad extra: 
    - Filtrar y eliminar paquetes "viejos" menores a un id de paquete

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 4 — Day 10

### Content

Skill 8.2: Modelar datos estructurados de tipo objeto

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 10

**Status:** Approved

### Teoría

  + Objetos: 
    - Concepto de modelos vs objetos
    - Propiedad vs Valor
    - Métodos (propiedades que son funciones)
    - Combinación de tipos de Datos: 
      -- Ej: array de objetos, objetos anidados

  + Modelado de objetos mediante diagramas de clases

### Thinking Framework

#### Thinking Development
- Aplicar el concepto de abstración para representar objetos del mundo real en modelos
- Entender la diferencia entre un modelo y un objeto
- Entender la diferencia entre una propiedad y un valor
- Diferenciar entre una propiedad y método
- Identificar relaciones entre objetos

#### Best Practices
- El modelo debe partir desde lo más general

#### Patterns
- Mantener los modelos lo más general posible 

- Schema Uniforme: Mantener la estructura de los objetos

#### Anti-patterns
- Objetos "Copo de Nieve": Crear objetos que deberían representar lo mismo (ej: usuarios) pero con estructuras diferentes.

{ nom: "Ana" } vs { nombre: "Juan" }.

- Relaciones circulares entre modelos/clases

#### Constraints & Limitations
- No IA

## Week 4 — Day 10

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1:
  1. Usando `https://online.visual-paradigm.com/app/diagrams/#diagram:proj=0&type=ClassDiagram` modela "Un reproductor de Playlist de Música" como Spotify, donde las canciones son objetos individuales que viven dentro de una lista.
  2. Se debe colocar los tipos de datos a las propiedades. 
  3. Debe tener al menos 5 modelos. 
  4. Se debe indicar qué modelos se relacionan entre sí.
  5. Exporta el resultado en PNG para entregar

> Proyecto 1:
  1. Usando https://online.visual-paradigm.com/ modela "Una billeta digital" como Wise, donde exista un historial de movimientos.
  2. Se debe colocar los tipos de datos a las propiedades. 
  3. Debe tener al menos 3 entidades. 
  3. Se debe indicar qué modelos se relacionan entre sí.
  4. Exporta el resultado en PNG para entregar

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 11

### Content

Skill 8.3: Trabajar con datos estructurados de tipo objeto en TypeScript

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 11

**Status:** Approved

### Teoría

  + Representación de objetos en TS: 
    - Interfaces vs Objetos literales 
      - Sintaxis 
      - Atributo vs Valor 
      - Acceso a propiedades
        - Notación punto (nombre.atributo) vs Notación corchete (nombre['atributo'])
        - Operador "opcional": nombre?.atributo
      - Métodos
    - Manipulación de objetos 
    - Combinación de tipos de Datos: 
      -- Ej: array de objetos, objetos anidados
  + Mutaciones (ej real: un libro -inmutable- vs un cuaderno -mutable- ) 
   - Paso por referencia vs paso por valor
   - Tipos de datos que admiten pasos por referencias o por valor

### Thinking Framework

#### Thinking Development
- Representar el mundo real en objetos literales / clases
- Diferenciar un objeto de clase a un objeto literal 
- Identificar cuando existe un "paso por referencia" y cuando es un "paso por valor"
- Construir y manipular objetos

#### Best Practices
- Si varias variables tienen relación entre sí (parecen atributos de algo más), estudiar la posibilidad de un objeto

#### Patterns
CamelCase: { nombreUsuario: "Juan" }. Facilita el uso del punto (.nombreUsuario).

Bracket Notation: Entender que si la key viene en una variable, es obligatorio usar corchetes: objeto[variable]

Tipado correcto: { activo: true, edad: 25 }. Facilita operaciones matemáticas y lógicas después.

Optional Chaining: Enseñar el operador ?.: usuario.direccion?.cp. (Si direccion falta, devuelve undefined en vez de romper todo).

#### Anti-patterns
Atributos con espacios: { "nombre del usuario": "Juan" }. Obliga a usar sintaxis compleja ['...'] siempre.

La confusión del punto: Intentar usar una variable como key con notación de punto: objeto.variable (busca literalmente la key "variable").

Valores como texto: Guardar números o booleanos como strings innecesariamente: { activo: "true", edad: "25" }.

Hardcoding repetitivo: Escribir manualmente 20 objetos literales.

Asumir que un dato anidado existe

#### Constraints & Limitations
- No IA
- No se abordan la herencia ni el polimorfismo

## Week 4 — Day 11

**Status:** Proyecto
pendiente
aprobación

### Práctica

  - Mastering JS (ejercicios de objetos)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12

### Content

Skill 9: Comunicarse efectivamente con la IA para la creación de interfaces

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12

**Status:** Approved

### Teoría

  + Estrategias en la comunicación con la IA (Context & Anatomy):
    - Context Engineering
    - Word efficiency  
    - Mención de skill 0.4 (Hablar el lenguaje de la IA) para refrescar los tipos de formatos.

  + Convertir lo visual en especificaciones para la IA:
    - Introducción al "Vision-to-Spec": Cómo traducir un diseño visual (mental o imagen) a especificaciones técnicas en lenguaje natural.
    - Anatomía de un Prompt de UI: Rol (Senior Frontend Dev), Stack (React + Tailwind/Bootstrap), Restricciones y Contenido.
    - Descomposición Visual (The Box Model Mental): Aprender a pedir "contenedores", "filas", "columnas" y "grid" sin escribir CSS.
      -- Mención de skills (0 - 3) - aplicadas a este contexto/skill. 

  + El Proceso Constructivo del frontend:
    - Iteración Constructiva (The Painter’s Algo):
      -- Estructura (Wireframe).
      -- Contenido (Textos/Imágenes).
      -- Estilizado (Colores/Espaciado).
    - Camino de menor resistencia
    - Feedback Loop: Cómo decirle a la IA que algo "se ve mal" usando la terminología correcta (padding, margen, alineación).

### Thinking Framework

#### Thinking Development
Desarrollar abstracción Espacial: Capacidad de ver una web (ej. Spotify) y no ver "música", sino ver: Sidebar (fixed) + Main Content (scrollable) + Player (sticky footer).

Desarrollar  pensamiento Declarativo: Pasar de pensar en "cómo hacerlo" (imperativo) a "qué quiero obtener" (declarativo).

Entender que una Landing Page no es una sola instrucción, sino la suma de Navbar + Hero + Features + Footer. (Descomposición de Problemas)

Entender que la calidad de la respuesta depende de la calidad de la restricción

#### Best Practices
Mobile First (Mentalidad): Instruir al LLM para que el diseño sea responsive por defecto. "Asegúrate de que en móvil se vea en una columna y en desktop en dos".

Atomic Design (Simplificado): Enseñarles a pedirle a la IA que separe el código en archivos/componentes pequeños si el output es muy largo.

#### Patterns
El Patrón "Matrioshka" (Component Isolation)        Nunca pedir la página entera de una vez. Pedir componente por componente, de afuera hacia adentro o por secciones.

El Patrón "Role & Stack Priming"        Definir el contexto técnico antes de pedir nada para evitar código "vanilla" o librerías obsoletas.

El Patrón "Reference Injection"        Si el modelo es multimodal (acepta imágenes), subir un screenshot. Si no, describir la estructura basada en una grilla.

El Patrón "Dummy Data First"        Pedir a la IA que hardcodee datos falsos (arrays de objetos) para visualizar la UI antes de conectar lógica real.

El Patrón de Refinamiento (Drill-Down)        Ir de lo general a lo específico (Layout -> Componentes -> Estilos finos).

#### Anti-patterns
El "One-Shot Wonder" (La Bala de Plata):        Intentar generar el clon de Airbnb completo (Home, Detail, Checkout) en un solo prompt gigante.

El "Vague Designer" (Diseñador Vago) : Usar adjetivos subjetivos en lugar de técnicos.

El "Frankenstein Stack":        No especificar librerías, resultando en una mezcla de CSS puro, Bootstrap, estilos en línea y librerías raras.

La "Lógica Prematura":        Intentar programar la funcionalidad (ej. autenticación, base de datos) mientras se está diseñando la UI.

Asumir que la IA sabe qué todo lo que has estado "hablando" durante todo el projecto (ej. librerías usaste hace 3 prompts).

Escribir 4 párrafos de historia de la empresa que no afectan el código. (Desperdicia tokens y confunde la atención de la IA).

El Prompt "Adivina": "Hazme una página bonita para una tienda". (Demasiada entropía, la IA alucinará estilos aleatorios).

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto con IA: Replicar una website con React 
  - Replicar la home de airbnb.com  
  - Elaborar Prompts de visión a especificación y generación de componentes.
  - Recordar que debe ser mobile first
  - Pedir que comience el proyecto con un archivo "readme.md" o un defecto un .txt que contenga "el contexto" de la interfaz que desea construir.
  - Preparar al alumno con un discurso sobre el motivo de usar un stack que aún no maneja del todo, en este caso React.

> Instrucciones para el profesor:
  - Se evulará únicamente el resultado (no el código en sí), dentro de ello que sea responsive, accesibilidad, html semantico. 
  - Elaborar Prompts de visión a especificación y generación de componentes.
  - El profesor debe especificarles el stack 
  - Se evaluará el "readme.md" con el prompt o contexto inicial

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13

### Content

Skill 10: Construir un banco de memoria y reglas de contexto a partir de un código base preexistente

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13

**Status:** Approved

### Teoría

 + ¿Qué son las reglas para una IA de programación?
   - Alcances de las configuraciones y reglas de contextos: User vs Project. ¿Qué reglas son de preferencia personal y cuáles son de necesidad del proyecto?
   - Aplicación de reglas: description, globs, alwaysApply
     -- Eficiencia de tokens: 
        --- Ir de lo general a los especifico. Muchos contextos con pequeños. 
        --- Ir de los específico a lo general. Minímo contextos necesarios a la vez.
   - Tipos de aplicación: Always, Auto Attached (pattern), Agent Requested (agent decides), Manual (mention), LLM Oriented
 
 + Memory bank: Persistencia del conocimiento más allá del chat actual
   - ¿Qué es un banco de memoria? ¿Para qué sirve?
   - ¿Qué es el contexto del producto? Descripción general del producto y del negocio para un mejor contexto de lo que se quiere desarrollar
   - ¿Qué es el plan de implementación? ¿Cómo construirlo con la IA? ¿Cómo gestionarlo con la IA?
   
 + Skills: ¿Cómo tu agente puede aprender habilidades casi como Neo en Matrix?
   - ¿Qué son las skills para los agentes?
     -- ¿Cómo funcionan?
   - ¿Cómo puedo enseñarle nuevas skills al agente?
   - ¿Dónde puedo conseguir skills ya existentes? (https://skills.sh/)

### Thinking Framework

#### Thinking Development
- Comprender la importancia y funcionamiento de la jerarquía de reglas
- Controlar el uso de los contextos de aplicación de las reglas
- Saber crear y gestionar el banco de memoria 

https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents

#### Best Practices
- Usar Globs para reglas de formatos, utilidades y pruebas y agrupar por carpetas
- Mencionar ficheros 
- Comprender la estructura actual del proyecto. 

#### Patterns
- Crear un plan de implementación y luego señir el desarrollo a su ejecución
- Mantener un plan de implementación dinámico según las necesidades del proyecto
- Gestionar y mantener actualizado el banco de memoria
- Reglas claras, limitadas y específicas
- Agregar nuevas reglas en función de las necesidades repetitivas que se van identificando
- Contenidos curados y concretos, no ambigüedades o divagaciones
- Respetar las reglas del preexistentes del proyecto y sólo modifcar bajo consenso

#### Anti-patterns
- Desarrollar de forma imperativa (saltar el plan de implementación, dándole órdenes nuevas a la IA)
- Dictador Global: Sobreescribir reglas de proyecto o de equipo por preferencias personales
- Ser muy descriptivo y ambiguo en la definición de reglas
- Confianza ciega en la proactividad del agente
- Pegar conversaciones muy largas y difíciles de procesar.
- Crear un contexto únicamente técnico y omitir el negocio.
- Sobreescribir las reglas preexistente "solo porque no me gusta"

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1: 
  1. Rehacer el proyecto colaborativo (las vistas de un e-commerce), pero de forma individual, agregando progresivamente reglas para que la IA trabaje mejor
  + Instrucciones al profesor
    - Identificar reglas mediante el análisis del qué se hizo, qué errores se cometieron, qué buenas prácticas se quieren implementar, qué acciones siempre se deben realizar...
    - Elaborar Prompts de visión a especificación y generación de componentes.
    - Reconstruir la UI mediante IA definiendo reglas
> Proyecto 2: 
  🎨 Hito 3 — Ingeniería de UI impulsada por IA
  - Abrir el proyecto generado y comenzar a establecer reglas para ir modificando la versión actual con todo lo aprendido.
  - El proyecto debe resultar en un website creado con Tailwind CSS (HTML + CSS + Vanilla JS) que pueda incluir elementos componentes web comunes como dropdowns, modales... y tener todas las validaciones necesarias con Javascript (correo bien validad, por ejemplo)

  + Instrucciones al profesor
    - Elaborar Prompts de visión a especificación y generación de componentes.
    - Reconstruir la UI de la empresa mediante IA.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14

### Content

Skill 11: Identificar y definir componentes de una aplicación web

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14

**Status:** Approved

### Teoría

  + Arquitectura de Single Page Applications (SPA) y Empaquetado. 
     - Building or compiling your app
     - Build time vs Runtime
     - Arquitectura SPA (Single Page Application):
       -- Juzgando una página web (múltiples páginas)
       -- La ilusión de la navegación: Hashstring (#) vs Browser History.
  + Introducción a React y Next.js
     - ¿Qué es un Componente Web (en React)?
       -- ¿Cómo se crean?
       -- ¿Cómo se modifica el contenido en la web?
     - ¿Qué es Next?
       -- React vs Next
     - Organización del Proyecto: Estructura de carpetas: /pages (vistas) vs /components (piezas) vs /layouts
     - App Router: Folder and file conventions
       - Top-level folders & files
       - Routing Files
       - Nested routes
       - Route groups and private folders
       - Metadata file conventions
     - Renderizado del lado del cliente (CSR) vs del lado del servidor (SSR)
     - Introducción a componentes: Creando mi primer componente React en Next.js
       -- Introducción superficial a props, useState y useEffect (estandar hasta React 18)

### Thinking Framework

#### Thinking Development
Poder leer la estructura de archivos de un website con React y determinar si tiene mejores prácticas. 

Verificar que las rutas sean "url friendly" y "website taxonomi": pensar en como "agrupar" el website, por ejemplo, /product/id/1asfa-fgasf-afsasd-asd
si no que sea producto/bateria-carro

Pensamiento Estructural/Jerárquico: Diferenciar entre un componente que es una "Vista" (ej. Home.jsx) y uno que es un "Widget" (ej. Button.jsx).

La Ilusión de la Persistencia: Comprender que al navegar en una SPA, el navegador no "refresca". El alumno debe mentalizarse en que está inyectando contenido dinámicamente, no cambiando de archivo HTML.

Abstracción del Layout: Habilidad para identificar qué partes de la web son constantes (Navbar, Footer) y qué partes son dinámicas (Outlet).

Poder estar familirizado/cómodo navegando el "codebase" del proyecto. 

#### Best Practices
Clean Routing: Definir las rutas en un archivo separado o claramente en el entry point, no esparcidas.

Componentes Funcionales: Prohibido usar Class Components (la IA a veces recurre a ellos si aprendió de datos antiguos).

Nombrado Semántico: Las vistas se llaman HomePage, ContactPage para diferenciarlas de componentes pequeños.

#### Patterns
El Patrón "Layout Wrapper": Instruir explícitamente a la IA para crear un componente "Layout" que contenga el Navbar y el Footer, y use un Outlet (o children) para el contenido. Evita repetir código en cada página.

El Patrón "Route Map Definition":  Antes de pedir código, definir el mapa del sitio en una lista. Esto ayuda al LLM a visualizar la totalidad del router main.jsx.

El Patrón "Folder Structure Enforcement" :Los LLMs tienden a poner todo en la raíz. Hay que forzar la separación de conceptos.

El Patrón "Link over Anchor":  Instruir específicamente el uso del componente <Link> en lugar de etiquetas <a> para mantener el estado de SPA.

#### Anti-patterns
El "Hard Refresh" Trap (La Trampa del <a>): Dejar que la IA use <a href="/contact">.

El "Redundant Layout" (Copy-Paste): Pedir "Crea la página Home" y luego "Crea la página Contacto" por separado sin contexto.

El "Monolithic App" :  Dejar que la IA meta todo el código de las 3 vistas dentro de App.js usando renderizado condicional manual (if (page === 'home')...).

Ignorar el Build Error: Tratar de arreglar errores de compilación (Build Time) como si fueran de lógica (Runtime).

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15

### Content

Skill 12: Implementar interfaces interactivas con React + Next.js

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15

**Status:** Approved

### Teoría

   + Fundamentos de React y Next.JS
     - Props
       -- Props más comunes
       -- Prop 'Children'
     - Hook pattern
       -- use (sustituto de useState y useEffect a partir de React 19)
       -- Custom hooks
     - Principales Hooks de Next.js
       -- usePathname
       -- useSearchParams
       -- ¿Qué son las Query strings?
     - Renderización
       -- Controlando los renderings (re renderizado)
       -- Error: Si se renderiza el padre, lo hará también el hijo
       -- Error: useEffect sin limitación de disparadores
     - Renderizado del lado del cliente (CSR) vs del lado del servidor (SSR)


  + Organizando mi frontend
    - Modularización: ¿Qué es un módulo?
      -- Por qué modularizar mi aplicación
    - Ejercicio donde se plantea una modal en la raíz de los componentes y en el que debería crear una nueva modal, para que responda cómo reorganizaría los archivos y se evalúe su respuesta 
      -- (la respuesta debería ser crear una carpeta "modals" con las variantes modal1 y modal2)
    - Referencia a las carpetas más importantes adicionales a la estructura de Next (como libs, types, hooks, entre otras...)

### Thinking Framework

#### Thinking Development
- Saber identificar y aplicar propiedades a un componente.

- Saber modificar el renderizado (output) de un componente basado en variables. 

- Entender y diseñar estados de los datos de los componentes y modificar el renderizado de componentes basado en estos estados.

- Identificar los efectos secundarios que produciran el cambio de los datos en el componente y sus dependencias para la renderizacion o comunicación de otros componentes

#### Best Practices
- Un use, una acción
- Limitar los disparadores del useEffect
- 

#### Patterns
- CustomHooks para promover DRY (y siempre con return)
- Callback function props para ampliar la reutilizabilidad del componente
- Estados objeto para datos estructurados

#### Anti-patterns
- Prop Drilling
- Props maestros (configuración masiva en un prop)
- Repetir fetch entre componentes en lugar de usar un CustomHook

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15

**Status:** Proyecto
pendiente
aprobación

### Práctica

  - Juegos tipo Kahoot! 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 16

### Content

Skill 13: Entender la web architecture y el flujos de datos en ella

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 16

**Status:** Approved

### Teoría

  + ¿Cómo es el flujo de datos en una aplicación de React y Next.js?
    - MVC: store, actions
    - LocalStorage vs SessionStoragecd .
      - ¿Cuándo almacenar algo en el storage?
    - Dependencia de los datos:
      -- ¿Cómo se usa el `use` para controlar la dependencia de datos?

  + Sesiones (NO MENCIONAR PROCESOS DE AUTENTICACIÓN)
    - ¿Qué es una sesión?
    - ¿Por qué una sesión puede no requerir autenticación?
    - Sesión como primer mecanismo de "memoria" (recordar al usuario)
    - ¿Cuándo almacenar o recordar algo en la sesión?
    - Ciclo de vida de una sesión
      -- La primera interacción con el sistema (Session init)
      -- Siguientes interacciones
      -- Destrucción de la sesión 

  + Promises
    - ¿Qué es una promesa? ¿Por qué es importante en el frontend?
    - Estados: pending, fulfilled (resolve), rejected (reject)
    - Gestión de promesas:
      -- ¿Qué pasa si no llegan o llegan tarde los datos?
      -- .then(...)
      -- async / await
      -- ¿Cuándo usar el Promise.all()?
    - Ejemplos de Promesas:
      -- Obtener datos de una dirección web (Solo con GET)
      -- Promesas en el manejo del LocalStorage
      -- Validación dentro de promesas (condicionando los resolve y reject)
    - Introducción al error handling
      -- .catch() (en Promise directas y fetch)
      -- try - catch (en async / await)


      

### Thinking Framework

#### Thinking Development
- ¿cómo superar la pantalla blanca de error en la que no carga la vista? 
- utilizando el network tab (DevTools) y entendiendo el flujo de los datos
- Comprender el funcionamiento e importancia de las promesas
- Gestionar adecuadamente las promesas (resueltas y rechazadas)
- Diferenciar la función del LocalStorage y el SessionStorage

#### Best Practices
- Promise.all para no encadenar múltiples async / await no relacionados entre sí

#### Patterns
- MVC 
- Promise
- Async / Await
- One way data flow: Datos padre->hijo, Eventos hijo->padre
- Store solo modificado por función pura
- Actions de Store solo para acceder y modificar información del Store
- UI de tres estados: Pending: Spinner/Skeleton; Fulfilled: Datos; Rejected: Mensaje de error.

#### Anti-patterns
- Gestión de errores con if/else
- Emplear el LocalStorage para almacenar datos sensibles
- Optimismo ciego: asumir que siempre se resuelve la interfaz
- Gestionar errores dentro de la promesa en lugar de esperar a resolver la promesa.

#### Constraints & Limitations
- Llamadas a APIs solo con GET

## Week 6 — Day 16

**Status:** Approved

### Content

⚛️ Hito 4 — Fundamentos de Next.js (React)
 Arquitectura SPA (Single Page Applications) y multipágina, props/state/effects, debugging. Construir el frontend interactivo de la empresa.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 17

### Content

Skill 14: Interacting with APIs

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 17

**Status:** Approved

### Teoría

  
  + Comunicarse con APIs externas: 
    - ¿Qué son las APIs y cómo funcionan?
    - Métodos principales: GET, POST, PUT, PATCH, DELETE
    - Request:
      -- Headers: Principalmente Content-Type y Authentication
      -- Body (html encode, params raw) 
        --- Files (mención)
    - Response: No todo error es un crash.
      -- Status Code
      -- Body/data
    - Herramientas y Autenticación: 
      - Postman
      - Autenticacion básica. 

  + Stateless comunication: El servidor tiene amnesia
    - Hay que pasarle al endpoint toda la informacion que necesita, siempre, no hay manera que el backend te avise algo hay que pedirselo
    - Lo más parecido a un state se llama polling que es hacer request/peticion cada x segundos 


  

### Thinking Framework

#### Thinking Development
- Comprender cómo se comunican los distintos entornos (frontend,backend, base de datos)

- Identificar semanticamente qué tipo de petición se necesita (get, post, ...) 

- Analizar la respuesta e identificar su cohorencia con la petición realizada. 

- Aprender a usar herramientas: postman, network tab, etc. 

- Realizar las peticiones basadas en el comprendimiento de "stateless comunication" 

- Identificar las necesidades de la petición (text, json, files) 

- Aprender a leer los payload, responses, headers, etc. 

#### Best Practices
- Separar las llamadas a APIs fuera de las actions del Store.
- Custom hooks para gestionar las peticiones a APIs

#### Patterns
- Lectura de Códigos: 200, 300, etc. 

- La Mochila Completa: Cada petición es un viaje nuevo. Debes llevar tu pasaporte (Token) y tu dirección (IDs) cada vez que sales.

- Headers Explícitos: Configurar siempre el Content-Type y el Authorization antes de enviar.

#### Anti-patterns
"Ya te dije quién soy": Hacer el Login en la petición 1, y en la petición 2 no enviar el Token, esperando que el servidor recuerde la sesión anterior.

- El Header Olvidado: Enviar un JSON en el Body pero olvidar poner Content-Type: application/json. El servidor no sabe cómo leerlo y falla.

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 18

### Content

Skill 15: Debugging and optimizing the frontend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 18

**Status:** Approved

### Teoría

   + Debugging: 
     - Dev Tool: Evidencia sobre suposición. 
       -- Elements
       -- Console
       -- Network tab
       -- React developer tools. (tal vez) 

  + Midiendo el desempeño del frontend (Core Web Vitals)
    - ¿Por qué es importante medir y optimizar el frontend?: No puedes mejorar lo que no mides. 
    - Métricas principales: First Contentful Paint, Total Blocking Time, Largest Contentful Paint

  + Estrategias de optimización del frontend:
    - Carga de Código (Code Splitting & Lazy Loading)
    - Rendimiento en Runtime (Memoization & SRP)
    - Principio de responsabilidad única (SRP)
    - Memoization
      -- Hook useMemo
      -- React.memo
    - Patrones de Reutilización: Custom Hooks vs. HOCs vs. Render Props 
    - Cache memory: La petición más rápida es la que no se hace.

### Thinking Framework

#### Thinking Development
- Identificar el tipo de problema utilizar la herramienta adecuada. 

- Reconocer los tipos de casos de uso más comunes que conllevan errores

- Identificar qué componentes son reutilizables
- Identificar qué componentes necesita el usuario para interactuar (evitar carga innecesaria de componentes) 
- Identificar qué lógica es reutilizable para convertir en un CustomHook
- Aprender a seperar ""preocupaciones"" para entender el alcance de SRP o evaluar qué tan pequeños seran los módulos (componentes)

#### Best Practices
- Limpiar el código de mensajes de debugging cuando se hace el pase a producción

- Evitar que un error rompa el flujo de la aplicación

#### Patterns
- UI de tres estados: Pending: Spinner/Skeleton; Fulfilled: Datos; Rejected: Mensaje de error.

- Breakpoints (Debugger)

- Prototipado en Browser: Modificar estilos directamente en la pestaña "Elements" para ver el resultado instantáneo y luego copiar al código.

- Autopsia de Petición: Abrir Network, filtrar por "Fetch/XHR", hacer clic en la petición roja y revisar las pestañas Payload (lo que envié) y Response (lo que me respondieron).

"- Network Throttling: Usar las DevTools para simular ""Fast 3G"" y ""CPU Slowdown"". Optimizar para el dispositivo promedio, no el gama alta.

- Percepción de Usuario: Priorizar LCP (que se vea algo rápido) y TBT (que los botones funcionen). Si carga en 0.5s pero no clickea, el usuario se va.

- Route-Based Splitting: Lo primero que se debe dividir son las Rutas/Páginas. Si estoy en /home, no necesito cargar el código de /dashboard. Después, modales pesados o componentes muy abajo en el scroll.

- Componentes Grandes: Lazy load solo para cosas pesadas: Gráficos (Chart.js), Mapas, Editores de Texto, o Rutas completas.

- Usar useMemo solo para cálculos costosos. 

- Custom Hooks: Usar hooks para compartir lógica (useAuth, useTheme). Es más limpio, no añade anidación al DOM y sigue el flujo natural de funciones.

- Stale-While-Revalidate: Usar librerías (TanStack Query, SWR) o caché de Next.js. Muestra los datos viejos instantáneamente mientras busca los nuevos en segundo plano."

#### Anti-patterns
Console Driven Development: Llenar el código de console.log("entré"), console.log("aquí") y recargar la página 20 veces.

- CSS a ciegas: Cambiar el CSS en el editor de código, guardar, mirar, volver a cambiar. (Lento).En este caso, gasto de tokens inecesarios

- "No funciona": Decir que la API falló sin abrir la pestaña Network.

- "En mi máquina funciona": Probar el rendimiento en una MacBook Pro con Fibra Óptica. Todo se ve rápido ahí.

- Lighthouse al 100%: Gastar 20 horas para subir de 95 a 100 puntos en métricas que el usuario no nota.

- Micro-Splitting: Hacer lazy import de un botón o un ícono pequeño.

- Memoización por Defecto: Envolver const valor = a + b en useMemo.

- Wrapper Hell (HOCs): Envolver componentes en 5 capas: withRouter(withAuth(withTheme(Component))). Hace el árbol de React inleible en DevTools.

- Fetch en cada Click: Volver a pedir la lista de usuarios cada vez que vuelves a la pestaña "Usuarios".

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 18

**Status:** Proyecto
pendiente
aprobación

### Proyecto

  - Generar una aplicación de frontend con V0 (de Vercel) o Stitch (de Google)
  - Incorporarla al 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 19

### Content

Skill 16.1: Coding in python as programming language in backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 19

**Status:** Approved

### Teoría

  - (Mención a Skills 6 y 7)

  + Introducción al backend
    - ¿Qué es el backend?
      -- ¿Cuál es el rol del backend?
      -- Lenguajes de backend más utilizados

  + Intro to Python
    - ¿Qué es Python?
      -- ¿Cómo funciona Python?
    - ¿Cómo se escribe código en Python?
        -- ¿Qué es la sintaxis?
        -- Reglas principales de la sintaxis de Python
    - Variables

  + Tipos de datos y operadores básicos de Python: 
    - Tipos de Datos primitivos (int, float, bool, str, None)
    - Operadores en Python (aritméticos, asignación, comparación, lógicos) 
  
  + Control de flujos en Python
    - Flujos simples: Condicionales (if, elif, else)
    - Flujos repetitivos: Bucles
      - for..in (con range, con listas de elementos clave-valor) y for en línea (List Comprehensions)
      - interruptores de flujo: break (para cortar la ejecución) y continue (para saltar esta iteración)
      - Bucles anidados
    - Ciclos: for..in (con range, con listas de elementos clave-valor) y for en línea (List Comprehensions)
    - Identificar oportunidades de mejora en ciclos anidados: Big O Notation (contenido referencial no muy profundo)

### Thinking Framework

#### Thinking Development
- Aprender una nueva sintaxis asociando con un lenguaje ya aprendido.

- Convertir soluciones de pseudocódigo a la sintaxis del lenguaje.
 
- Aprender a investigar siempre que sea necesario. (memorizar no es una habilidad a desarrollar, se dará con la práctica) 

- Identificar cuándo se hace uso de una palabra reservada. 

- Aprender a identificar tipos de datos por su valor (su composicion). 

- Comprender las diferencias de los tipos de datos

- Identificar los casos de uso de cada tipo de dato

#### Best Practices
Escribe el codigo, no lo copies

#### Patterns
- snake_case para variables y funciones

- para definir clases: PascalCase 

- Logs Etiquetados: print("El valor de x es:", x)

- Nombres Semánticos

- Identacion y " : " como indicador de bloques

#### Anti-patterns
- Buscar la sintaxis perfecta. 

- Usar código mágico (copiar y pegar, no tener concimiento de lo que hace código)

- Inconsistencia en la sintaxis (no mantener decisiones anteriores en estructura, patrones, etc)

- Crear bucles infinitos

- Condiciones kilométricas 

- Exceso de anidación de condicionales: if dentro de if dentro de if... formando una flecha a la derecha. 

#### Constraints & Limitations
- No IA

## Week 7 — Day 19

**Status:** Approved

### Content

Ejercicios de JS que deban traducirse a Python.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 7 — Day 20

### Content

Skill 16.2: Escribir bloques de código con nombres (funciones)
Skill 17: Trabajar con tipos de datos estructurados de tipo listas y diccionarios

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 20

**Status:** Approved

### Teoría

  - (Hacer mención a Skill 8.1)

  + Funciones Python
    - ¿Qué es un bloque de código?
    - Dar nombre a un bloque de código (creando una función)
    - Párametros (cómo pasar valores a una función)  
      - Incluye breve referencia a *args y **kwargs
    - ¿Cómo devuelve valores una función? (funcionamiento del return y especificación del tipo de dato devuelto) 
    - Métodos vs funciones vs procedimientos (funciones que devuelven valor y funciones que no)
    - Métodos y funciones para trabajar con datos primitivos (string, number, etc)  
    - funciones anónimas (lambdas)

  + Listas y diccionarios en Python
    - Listas (Array)
      -- Iteradores más comunes: Map y Filter
    - Tuplas (Lista ordenada inmutable)
    - Conjuntos (Set - Listas no ordenadas sin duplicados)
    - Diccionarios
      -- Notación corchete (nombre['atributo'])
      -- Métodos útiles: get(), update(), defaultdict()

### Thinking Framework

#### Thinking Development
"- Desarrollar un flujo si hay un objetivo solo, que son: 
 -- Mutar un valor de un proceso global
 -- obtener un valor y retornarlo
- Reconocer los valores que necesita mi funcion para lograr su objetivo
- Reconocer el tipo de funcion que requiero
- Mantener el principio de responsabilidad única
- Comprender diferencia entre listas, duplas, conjuntos
- Definir y manipular una lista, dupla o conjunto
- Buscar elementos en una lista, dupla o conjunto
- Ordenar listas
- Identificar cuando existe un ""paso por referencia"" y cuando es un ""paso por valor""
- Construir y manipular diccionarios

#### Best Practices
-  Aprender a gestionar listas con bucles y con métodos del lenguaje.

- No memorizar.  Investiga cada que necesites usar un método

- Elegir un nombre adecuado en las funciones, el nombre debe ser descriptivo a lo quehace la misma 

#### Patterns
- Homogeneidad en arrays/colección

- Iterar copia o Inversa

#### Anti-patterns
- El Cajón de Sastre: listas con varios tipos de datos.

- Mutación durante iteración 

- Acceso:        Usar lista[100] sin verificar el tamaño, devuelve error.

- Abuso de funciones lambda

#### Constraints & Limitations
- No IA

## Week 7 — Day 21

### Content

Skill 18: Answering front end user-triggered requests

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 21

**Status:** Approved

### Teoría

  (Referencia a la Skill 13)

  + Introduction to FastAPI
    - ¿Qué es un framework?
    - ¿Por qué es importante un framework para construir una API?
    - ¿Qué es FastAPI?
    - Elementos principales de FastAPI (estructura base, endpoints, ApiRouter, modelos)
    - Instalando FastAPI
      -- ¿Qué es un virtual env?
      -- ¿Qué es Pipenv?
      -- pipenv vs. pip + venv

  + Building a Python API to serve the frontend
    - ¿Qué es una API? (refrescamiento de conocimientos)
    - ¿Qué es un endpoint? ¿Para qué sirven?
    - Construyendo los endpoints que necesita el frontend
      -- ¿Qué significa CRUD?
      -- Trabajando con llamadas GET, POST, PATCH/PUT, DELETE (sin almacenamiento)
    - ¿Por qué es fundamental realizar validaciones en todos los endpoints?
    - Serializando la respuesta como la quiere el frontend 
    - Documentación con FastAPI
  

### Thinking Framework

#### Thinking Development
- Las APIs se prueban con tests y clientes HTTP (Postman, Insomnia...) no con frontend
- Asociar métodos HTTP con acciones concretas de un endpoint
- Comprender que el backend no persiste datos.
- Entender las necesidades del frontend para dar respuestas acordes
- Validar la documentación generada por FastAPI
- la documentación se genera sola si usas bien los tipos Pydantic.
- FastAPI usa Pydantic para validar que los datos sean correctos antes de que entren a tu función.
- Recursos (Sustantivos): POST /users, GET /users. La URL define qué es, el método define qué haces.

#### Best Practices
- Acompañar un código HTTP con un mensaje siempre que se considere necesario y útil.

#### Patterns
- Endpoints con métodos HTTP específicos (no generalistas)
- Serializar las respuestas de los endpoints
- Principio de única responsabilidad (single-responsibility, S en SOLID)
- Siempre responder con el código HTTP correcto
- Un endpoint, una responsabilidad

- Apalancamiento: Usar FastAPI para lo que es bueno: Validación de datos, Enrutamiento y Generación de documentación automática.
- Python Moderno (Type Hints)
- Recursos (Sustantivos): POST /users, GET /users.
- Consistencia de recursos: mantener el sustantivo de recurso, una vez definido para todos sus metodos http.
- Mapping / Alias: Configurar Pydantic para que acepte/envíe camelCase (JSON) pero tu código Python use snake_case. O acordar un estándar único.

#### Anti-patterns
- Reinventar la Rueda: Intentar parsear el JSON del body manualmente o escribir un servidor de sockets desde cero "para aprender".

#### Constraints & Limitations
- Sin BD

## Week 8 — Day 22

### Content

Skill 19: Almacenar información desde el backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 22

**Status:** Approved

### Teoría

  + Trabajar con ficheros en Python
    - ¿Qué es un archivo? Datos persistentes en disco.
      -- Codificación de archivos (encoding, utf-8 por defecto)
      -- Rutas (path) absolutas y relativas
    - Abrir y leer archivos
    - Crear y escribir en archivos
    - ¿Qué es un archivo CSV?
      -- Crear una lista de diccionarios a raíz de un CSV
      -- Volcar una lista de diccionarios en un CSV

### Thinking Framework

#### Thinking Development
- Saber alimentar un listado de datos estructurados desde un archivo CSV
- Saber volcar un listado de datos estructurados a un archivo CSV

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- with open(...): siempre
- encoding="utf-8" explícito
- Validar exists() antes de leer si aplica
- Procesar en streaming para grandes

#### Anti-patterns
- open() sin with (archivos “colgados”)
- Usar w sin querer (pierdes datos)
- Meter texto libre sin \n (salida pegada)
- readlines() en archivos grandes

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 22

**Status:** Approved

### Content

> Proyectos: 
+ Importador simple:
1. Lee students.csv
2. Genera report.json con:
  - total estudiantes
  - promedio score
  - top 3 scores
  - lista de errores (filas mal formadas)"

+ Exportador simple
1. Obtiene un listado de productos a partir de una BD
  - nombre, marca, código, precio, unidades disponibles
2. Generar un CSV para exportar

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 23

### Content

Skill 20: Alimentar datos estructurados a partir de archivos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 23

**Status:** Approved

### Teoría

  + Almacenando información para el frontend (en cualquier lugar)
    - ¿Qué es una base de datos? Como concepto general
    - ¿Por qué es necesario el almacenamiento de datos?
    - Cómo guardar datos de forma simple con TinyDB y el método .save()  
      -- Usando TinyDB como base de datos de rápida implementación (No queremos dar SQL todavía, pero si poder persistir datos en una BD)
      -- insert, search, delete, update
    - Cargando datos iniciales en mi aplicación
      -- Cómo crear un seeder bastante simple
      -- Ejecutar seeders con pipenv run 

### Thinking Framework

#### Thinking Development
When teaching TinyDB, pair it with Pydantic as a lightweight schema/DTO layer to validate, serialize, and document data shapes, while TinyDB handles persistence of plain dictionaries.

- Generar datos iniciales "reales" en la base datos para realizar pruebas en la aplicación

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- Uso del .save()
- Aplicar persistencia en aplicaciones

#### Anti-patterns
- Almacenar información sin orden
- Almacenar información sin validar o verificar
- Hacer múltiples consultas del mismo recurso porque lo necesito de nuevo.

#### Constraints & Limitations
- No queremos dar SQL todavia, pero si poder persistir datos en una BD

## Week 8 — Day 23

**Status:** Proyecto
pendiente
aprobación

### Proyecto


### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 24

### Content

Skill 21: Implementar mecanismos de autenticación

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 24

**Status:** Approved

### Teoría

  + Autenticación
    - ¿Qué es la autenticación y por qué es importante?
      -- Resaltar la importancia de encriptar una contraseña
    - Autenticación vs. Autorización
    - Tipos de autenticación más conocidas
      -- Basic Auth: El abuelo (Usuario + Password en base64).
      -- Token-Based (JWT): El estándar actual. Estructura (Header, Payload, Signature).
      -- OAuth (Mención): "Entrar con Google/GitHub" (Delegación de identidad).
      -- Passwordless: Conocidos como Magic Links o Token Url
    - ¿Qué es la autenticación multifactor (MFA): Una breve referencia informativa
   
  + Seguridad de contraseñas en backend: Protegiendo las cuentas de nuestros usuarios
    - Cuáles son los requisitos mínimos actuales para que una contraseña sea segura (12 caracteres: letras, números y símbolos)
      -- ¿Por qué es peligroso guardar las contraseñas en texto plano?
    - ¿Qué es el cifrado de contraseñas?
      -- Hash y Salting (Nunca guardar texto plano)
      -- Algoritmos de cifrado más seguros actualmente
      -- Algoritmos de cifrado desaconsejados por inseguros
    - Cómo cifrar una contraseña en Python
   
  + Autenticando con JWT
    - ¿Cómo funciona la autenticación por JWT?
    - ¿Cómo está estructurado el token de JWT? (Header, Payload, Firma)
    - Flujo de los datos en una autenticación por JWT
      -- Solicitudes y respuestas
      -- Alternativas de almacenamiento en frontend (LocalStorage, SessionStorage, Cookies seguras - HttpOnly)
    - Revocación: 
      -- Limpieza de tokens: Cierre o reinicio de la sesión de forma manual
      -- Expiración: Tiempo máximo de validez del token
    - Prácticas seguras:
      -- No introducir datos sensibles en el payload del token
      -- Mantener la SECRET_KEY en ENV VARS, no en el código ni en el repositorio
    - Cómo implementar un flujo de autenticación con JWT + FastAPI + Contraseñas Cifradas + TinyDB

### Thinking Framework

#### Thinking Development
- Saber diferenciar entre autenticación y autorización
- Conocer los principales tipos de autenticación
- Concientizar sobre la importancia de una autenticación segura
- Implementar una autenticación con JWT
- Concientizar sobre la importancia de almacenar las contraseñas cifradas

#### Best Practices
- Almacenamiento en el Cliente
- Establecer una expiración (Exp)
- Claves Secretas en ENV VARS: Mantén la SECRET_KEY segura y no la expongas en el frontend.
- Validación en el Servidor

#### Patterns
- JWT
- Contraseñas cifradas
- Rutas protegidas

#### Anti-patterns
- Introducir datos sensibles en Payload: contraseñas, tokens de sesión, o cualquier dato que no deba ser público. 

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 24

**Status:** Approved

### Content


### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 25

### Content

Skill 22: Creating authentication flows

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 25

**Status:** Approved

### Teoría

   + Sesiones en el Frontend
     - ¿Qué es una sesión? ¿Para qué sirve?
     - Mecanismos vs. Almacenamiento: Diferencia entre el protocolo (CÓMO me identifico) y la persistencia (DÓNDE guardo la credencial).
     - Stateful o centralizada (Session IDs) vs. Stateless o descentralizada (JWT)
     - Gestión de Tokens de sesión (El "Qué")
       -- Anatomía del Header: "Authorization: Bearer <token>".
       -- Formas de almacenamiento: LocalStorage. 
   
   + Implementando el ciclo de vida de un usuario en sesión: La autenticación no es una pantalla, es un sistema de estados.
     - Protected Routes: ¿Cómo evitar que un usuario vea /dashboard si no tiene token?
     - Creando sesiones (como sucede en el login)
     - Persistencia de Sesión: Manejo de LocalStorage/SessionStorage vs. Cookies (HttpOnly).
     - Terminando la sesión (como en un logout): Limpieza de estado y redirección.
     - ¿Qué hacer cuando el token expira?
       -- Eliminar token
       -- Redirigin a login

### Thinking Framework

#### Thinking Development
- Distinguir entre "el mecanismo" (ej: JWT) y el almacenamiento (LocalStorage/Cookies).

- Identificar el flujo de la autenticación que deseas manejar o cual se adapta mejor al requerimiento (forma de autenticar la cuenta del usuario o recuperar contraseña, etc.)

#### Best Practices
- Al dar feedback al usuario, evitar "dar información de más" por ejemplo: usuario no registrado o contraseña invalida, en vez de usuario o contraseña invalida. 

#### Patterns
- Verificación Real: Intentar usar el token en una llamada a la API. Si devuelve 401, borrarlo y mandar al usuario al Login.

- Estándar Bearer: Respetar el prefijo: Authorization: Bearer <token>. ("Bearer" significa "Portador").

- "Flujo Primero": Definir el diagrama de estados: Unauth -> Login -> Auth -> Logout -> Expired.

- Protección de Rutas (Guards): Crear un componente <PrivateRoute> que verifique el token antes de renderizar la página, y redirija si no es válido.

- Hydration (Hidratación): Al iniciar la app (useEffect inicial), buscar si existe un token guardado y validarlo para restaurar la sesión automáticamente.

- Solo Tokens: En el storage del navegador solo se guarda el Token. Los datos sensibles se piden al servidor usando ese token.

- Token-Based: Usar Basic Auth solo una vez para obtener el Token, y luego usar el Token (Bearer) para todo lo demás.

#### Anti-patterns
- Fe Ciega: Asumir que si hay algo guardado en LocalStorage, el usuario está logueado. (Podría ser un token viejo o texto basura).

- Decode != Verify: Creer que decodificar un JWT en el frontend (jwt-decode) garantiza que es válido.

- "Pantalla Primero": Diseñar el Login visualmente sin saber dónde guardarás el token o cómo protegerás las rutas.

- Seguridad por Ocultación (UI): Solo ocultar el botón "Admin" con CSS (display: none). Si el usuario conoce la URL /admin, entra igual.

- Datos Sensibles: Guardar la contraseña o datos de tarjeta de crédito en el LocalStorage. (Es accesible por cualquier script malicioso - XSS).

- Uso en Producción: Enviar usuario y contraseña en cada petición (Basic Auth) sin HTTPS.

- No enviar datos sensibles en el payload del token 

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 25

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto: Utilizar el proyecto del día anterior. Crear un flujo de autenticación en el frontend y conectarlo con el backend desarrollado en la clase anterior.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 26

### Content

Skill 23: Managing errors

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 26

**Status:** Approved

### Teoría

    
  + Error handling: La aplicación no debe explotar
    - Try/catch/finally
    - Prepararse para el peor escenario posible
      -- Defaults
      -- Renderizado condicional
      -- Optional chainning
      -- Fallbacks
    - Buenas prácticas
      -- Ningún error debe romper la aplicación
      -- Comunicar errores al usuario de forma adecuada (no entregar error técnico, explicar qué puede hacer)

  + Debugging with Python
    - 

### Thinking Framework

#### Thinking Development
- Reconocer los tipos de casos de uso más comunes que conllevan errores

- Saber gestionar adecuadamente los errores de código

- Comunicar el error o estado de la aplicación en términos adecuados según tipo el usuario. 

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- UI de tres estados: Pending: Spinner/Skeleton; Fulfilled: Datos; Rejected: Mensaje de error.

- Scope Específico: Usar try/catch específicamente donde ocurren operaciones peligrosas (llamadas a API, parseo de JSON, async/await).

Bloque Finally: Usar finally { setLoading(false) } para asegurar que el spinner de carga desaparezca, tanto si tuvo éxito como si falló.

- Traducción Humana: Mostrar: "Lo sentimos, no pudimos cargar tus datos. Por favor revisa tu conexión e intenta de nuevo."

- Call to Action (CTA): Ofrecer una salida: Botón "Reintentar", "Volver al inicio" o "Contactar soporte".

#### Anti-patterns
- Wrapping Gigante: Envolver toda la aplicación o funciones enormes en un solo try/catch.

- Mostrar al usuario: Error 500: Unexpected token < in JSON at position 0.

- Callejón sin salida: Mostrar un mensaje de error que solo dice "Error".

- Exponer datos sensibles debido a un proceso de depuración

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 26

**Status:** Approved

### Content

>

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27

### Content

Skill 23: Implementar pruebas unitarias para validar las funcionalidades

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27

**Status:** Approved

### Teoría

  + Introducción al testing
    - ¿Por qué probar un código?
    - Tipos de pruebas más conocidas:
      -- Pruebas unitarias (donde estará el foco del contenido)
      -- Pruebas funcionales (Introducción referencial)
      -- Pruebas de integración (Introducción referencial)
      -- Pruebas de rendimiento (Introducción referencial)
    - Introducción al TDD (Test-Driven-Development)

  + Unit testing with FastAPI:
    - Frameworks de testing más conocidos: unittest, pytest, doctest
    - Pruebas unitarias en FastAPI
         --- Prueba sobre la lógica del endpoint no sobre su serialización
    - Planificación de pruebas unitarias

  + Unit testing en Typescript:
    - Frameworks de testing más conocidos: Jest, Mocha/Chai, Vitest
    - Pruebas unitarias con Jest
    - Planificación de pruebas unitarias

### Thinking Framework

#### Thinking Development
- Reconocer la importancia de las pruebas unitarias como verificación adicional para la consistencia y robustez de una aplicación
- Comprender el valor de un desarrollo orientado a pruebas, más allá de aplicación en trabajos reales
- Saber implementar  pruebas unitarias en backend
- Entender cómo funcionan las pruebas unitarias

#### Best Practices
- Hacer pruebas de error (probar cómo reacciona cuando el resultado es erróneo)

#### Patterns
- Test Driven Development
- Identificar los casos límite y los casos más representativos

#### Anti-patterns
- Sobregeneración de pruebas
- Probar solo el resultado esperado

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto: Al proyecto de autenticación en la API, agregarle las pruebas unitarias de sus endpoints
 1. Plantear el problema a la IA e identificar los casos de estudio, los casos límite y aspectos a tener en cuenta
 2. Generar las pruebas unitarias para los distintos endpoints según sus casos de uso y casos límite
 3. Verificar que todas las pruebas se ejecutan correctamente y que el código funciona adecuadamente.
 + Actividad extra:
    - Revisar todos los proyectos de backend anteriores y aplicar pruebas unitarias

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 28

### Content

Skill 24.1: Consultar tablas y gestionar filas en bases de datos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 28

**Status:** Approved

### Teoría

  + Bases de datos (solo informativo)
    - ¿Qué es una base de datos?
    - ¿Para qué sirven las bases de datos?
    - Tipos de bases de datos más comunes
      -- Relacionales (SQL: Postgres, MariaDB/MySQL, SQL Server)
      -- Documentales (TinyDB, SQLite, MongoDB)
      -- Clave-Valor (Redis)
      -- Otros tipos de BB.DD.: Mención rápida a Grafos (para relaciones complejas) y Columnares (Cassandra)
  
  + Consultando bases de datos con SQL en PostgreSQL (Fundamentos de SQL)
    - ¿Qué es SQL y para qué se usa?
    - ¿Cómo funcionan las tablas relacionales? (Tablas, filas y columnas)
    - Identificadores primarios (Primary key)
      - Números autoincrementales
    - Tipos de valores
      -- numéricos
      -- texto
      -- booleanos
      -- fechas y horas
    - CRUD básico: SELECT, INSERT, UPDATE, DELETE
      -- ¿Por qué pedir columnas específicas en lugar de usar * en el SELECT?
      -- ¿Qué es un soft-delete? ¿Cuándo usar una columna para soft-delete en lugar de ejecutar un DELETE?
    - Filtrado: WHERE
      -- Operadores matemáticos (=, !=, <, >, <=, >=)
      -- Operadores lógicos (AND, OR, NOT)
      -- Operadores de rango (IN, BETWEEN)
      -- Operadores de texto (LIKE, ILIKE)
    - Ordenamiento y limitación: ORDER BY y LIMIT
    - Agregación: 
      -- GROUP BY
      -- COUNT, SUM, AVG, MIN, MAX, DISTINCT
      -- HAVING (al menos conceptual)
    - NULL (como concepto)
      -- ¿qué significa NULL en bases de datos?
      -- por qué = no funciona con NULL
      -- impacto en agregaciones
      -- Operador vacío (IS NULL)


  + Utilizando PostgreSQL en remoto con Supabase
    - ¿Qué es Supabase? (Orientado a BD en remoto)
    - ¿Cómo gestionar una BD en Supabase?
    - ¿Cómo hacer consultas a una BD de Supabase desde mi backend?

### Thinking Framework

#### Thinking Development
- Comprender formalmente el concepto de base de datos
- Conocer los tipos de bases de datos más populares y sus principales representantes
- Saber estructurar una consulta SQL
- Aprender a realizar los principales tipos de consultas SQL 
- Saber representar en bases de datos las relaciones entre objetos como tablas relacionadas

#### Best Practices
- nombres de tablas en plural

#### Patterns
- Atomicidad: Una celda = Un valor. Si hay muchas tallas, o son muchas filas o es otra tabla relacionada.
- Tipado Estricto: Entender que si la columna dice INTEGER, nadie puede escribir "Hola" ahí. La rigidez es una virtud, no un defecto.
- Modo Seguro: Primero haz un SELECT * FROM usuarios WHERE id = 5. Si devuelve lo que esperas, cambia el SELECT * por DELETE.
- Proyección Explícita: Pedir solo las columnas que se necesitan.

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA para la generación de Consultas SQL

## Week 10 — Day 28

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto en clases:
  Se provee un SQL que poble una BD con un conjunto de datos para que se busquen filtren filas y se extraigan ciertos datos.
  Luego, al estilo de CMD Challenge, deberán borrar una fila en específico, actualizar otra...

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29

### Content

Skill 24.2: Consultar tablas relacionadas con SQL

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29

**Status:** Approved

### Teoría

  + Gestionando tablas relacionadas con SQL
    - ¿Qué es una relación en bases de datos?
    - ¿Qué es un diagrama entidad/relación?
      -- Representar elementos de la vida real y sus relaciones como tablas en un diagrama E/R
    - Relaciones entre tablas
      -- Identificadores foráneos (foreign keys)
      -- Relaciones 1:1, 1:n, n:m
    - ¿Qué es una tabla pivote?
    - Cómo obtener construir un resultado con dos tablas relacionadas
      -- INNER JOIN
      -- LEFT/RIGHT JOIN
      -- OUTER JOIN
    - Qué es la normalización y por qué es aconsejable
    - (Solo informativo) ¿Cómo funciona un borrado en cascada?

### Thinking Framework

#### Thinking Development
- Comprender cómo se relacionan las tablas de una base de datos a través de una Foreign Key
- Entender la diferencia entre los tipos de JOIN y cuándo son útiles
- Crear consultas SQL que relacionen tablas usando JOIN
- Entender cómo funciona un borrado en cascada

#### Best Practices
- foreing key formato `nombre_tabla_id`

#### Patterns
- Normalización 
- Foreign keys para relacionar dos tablas
- Borrado en cascada para evitar datos huérfanos

#### Anti-patterns
- Usar columnas de tipo texto con múltiples valores en lugar de una tabla pivote

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29

**Status:** Proyecto
pendiente
aprobación

### Content

> Práctica: Ejercicios de modelados con diagram.4geeks.com
> Proyecto en clases:
  Se provee un SQL que poble una BD con diversas tablas relacionadas entre sí con un conjunto de datos para trabajar con ellas

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 30

### Content

Skill 25: Trabajar con datos estructurados de tipo objeto en Python

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 30

**Status:** Approved

### Teoría

  + Programación Orientada a Objetos:
    - ¿Qué es una clase?
    - Clases vs Objetos
    - Principios de la Programación Orientada a Objetos
      -- Abstracción
      -- Herencia
      -- Polimorfismo
      -- Encapsulación

  + Representación de objetos en Python: 
    - Clases (Base Class)
      -- Sintaxis
    - Atributo vs Valor
    - Notación punto (nombre.atributo)
    - Acceso a propiedades
    - Métodos
    - Manipulación de objetos

### Thinking Framework

#### Thinking Development
- Entender que con una sola Clase (Enemigo) puedo crear 100 Objetos distintos (orco1, orco2), cada uno con su propia vida y posición.

- Comprender que la aplicación de esta teoría es principalmente para la creación de modelos para la base de datos y leer código existente

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
Estado + Comportamiento: Una clase debe tener datos (self.vida) y métodos que modifiquen esos datos (recibir_daño()).

El Primer Parámetro: Explicar que self no es mágico, es solo una convención para el primer argumento. "Cuando el objeto actúa, necesita saber sobre quién actuar".

Atributos de Instancia: Siempre definir los atributos dentro del constructor:

Objetos dentro de Objetos: La clase Coche tiene un atributo self.ruedas, que es una lista de objetos Rueda.

Lista de Objetos: Una sola lista usuarios = [] donde cada elemento es una instancia de la clase Usuario.

#### Anti-patterns
La Clase Estática: Enseñar clases que solo son contenedores de funciones (como una clase Matematicas con métodos sumar). Eso no es POO, es agrupación de funciones.

Acceso Total: Modificar atributos desde fuera sin control: jugador.xp += 100. Si luego quieres poner un límite de nivel, tendrás que buscar en todo el código.

Herencia Profunda (Deep Hierarchy): Animal -> Mamifero -> Canino -> Perro -> Caniche. Es imposible de mantener.

Funciones Externas: Crear funciones fuera de la clase que manipulan al objeto.

Declarar variables fuera del __init__.

Datos Primitivos: coche.rueda1_presion, coche.rueda2_presion.

Arrays Paralelos: Tener nombres = [] y edades = []. Si ordenas uno, el otro se desincroniza.

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 31

### Content

Skill 26: Relacionando objetos y tablas utilizando un ORM

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 31

**Status:** Approved

### Teoría

  + Object-Relational Mapping: El traductor universal
    - ¿Qué es un ORM?
      -- El ORM no exime el dconocimiento sobre SQL
    - Definición de Modelos y Tipos de Datos
      -- La correspondencia:
         Clase (Python) -> Modelo (sqlmodel) = Tabla (SQL).
         Instancia/Objeto = Fila/Registro.
         Atributo = Columna.
    - Migraciones
    - Relaciones
      -- 1:1
      -- 1:n
      -- n:m
    - Sesiones y Transacciones (introducción debido a los métodos necesarios)
      -- db.session
      -- Commit vs Rollback (sólo para actualizar datos y "manejo de errores")
    - ORM bien usado (evitar N+1, eager/lazy loading consciente, límites de transacciones)
 
  + Gestionando la evolución de la base de datos con FastAPI
    - ¿Qué son las migraciones de un BD?
    - ¿Qué ventajas tienen?
    - ¿Cómo se crean y usan las migraciones en FastAPI?
    - ¿Cuándo usarlas y cuándo no usarlas?

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 31

**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1: API con conexión a BD haciendo consultas SQL (consultas + Pydantic)
  - Obtener 
> Proyecto 2: Replicar la misma API y conectarla a una BD usando ORM (SQLModel)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 32

### Content

Skill 27: Diseñar la arquitectura del backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 32

**Status:** Approved

### Teoría

  + Arquitecturas más comunes en el backend
    - MVC
    - Arquitectura en capas (introducción a la arquitectura hexagonal, muy light)
    - Serverless

  + Web App Architecture optimized for front-end user traffic
    - Caching
      -- cache en memoria (app)
      -- cache distribuida (Redis)
      -- cache HTTP/CDN (si aplica)
    - Serializers
      -- validación de inputs (prompt, parámetros)
      -- outputs grandes (streaming, chunking)
      -- formatos (JSON, multipart)
 
  + Modularización en Python: PEP8
    - Imports : absoluta y relativa (__init__.py)
    - Importación con ali (as)
    - ¿Cómo evitar importaciones circulares?

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 33

### Content

Skill 28: Cómo optimizar el almacenamiento para reporte, integridad, consulta o transporte

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 33

**Status:** Approved

### Teoría

- Elegir el engine de base de datos (SQL o NoSQL)

- Elegir el transporte de datos (JSON, CSV, YAML, TOON)

- Elegir la forma de los datos (1ra or 3 forma normal)
     -  Los reportes estan normalizados para velocidad de consulta y usualmente no se usan BD relacionales porque estan optimizadas para escritura
     - Las acciones del usuario y sus consecuencias son escrituras constantes, se almacenan en 3ra forma normal para evitar redundancia y garantizar integridad

 - Tabla comparativa entre los modelos más grandes del mundo (Dynamo, MySQL, Postgres, MS Server, BigQuery, Redis, Mongo, etc) 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 34

### Content

Skill 29: Collecting telemetry and context-related info from the user and your application

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 34

**Status:** Approved

### Teoría

+ Entendiendo la telemetría desde el frontend
  - ¿Qué es la telemetría? ¿Por qué es importante y útil?
  - ¿Qué datos almacenar? (categorías mínimas)
    -- Identidad / sesión
    -- Perfil de usuario (personalización): role/persona, plan, language, timezone, country, preferences (tema, notificaciones), accessibility.
    -- Contexto de ejecución: appVersion, env, route, referrer, utm, featureFlags, tenant/academyId.
    -- Uso del producto (telemetría): eventos de navegación, clicks clave, funnels, tiempos, errores, búsquedas internas.
    -- Rendimiento: Web Vitals, API latency, CSR/SSR timings, re-renders (si aplica).
    -- Calidad / soporte: errorId, stack (sanitizado), networkState, apiStatus.
    -- Privacidad y consentimiento: consent.analytics, consent.marketing, consent.functional.
  - ¿Para/Por qué almacenar esos datos? (objetivos claros)
    -- Personalización: contenido/UX según role, idioma, preferencias.
    -- Analítica de producto: entender rutas, drop-offs, features usadas, cohortes.
    -- Observabilidad: detectar errores, degradación de performance, incidencias por versión.
    -- Experimentos: A/B testing y feature flags (impacto y segmentación).
    -- Soporte: reproducibilidad (session + contexto + breadcrumbs).
  - “User profile” vs “usage data” (separación práctica)
    -- User profile: se guarda como estado (persistente) y se actualiza cuando cambia (ej. PATCH /users/me).
    -- Usage data: se envía como eventos (append-only) a telemetry/events.

+ Enviando telemetría desde el frontend de mi aplicación
  - ¿Cómo se deben almacenar los datos? (formato y contrato)
    -- Modelo por evento (recomendado): JSON consistente.
    -- Campos base: event (string), timestamp (ISO), user (obj), session (obj), context (obj), properties (obj).
    -- Propiedades tipadas y estables (evitar cambios frecuentes de nombres).
    -- Información de identificación personal minimizada: email/teléfono no en telemetría; usar IDs hash/opaque.
  - ¿Cómo transmitirlos al backend? (React/Next)
    -- Endpoint único: POST /telemetry/events (Batch + debounce: enviar arrays (events: []) cada X segundos o al llegar a N eventos)
    -- Auth: token/cookie; si anónimo, anonymousId persistido (localStorage/cookie).
    -- Fiabilidad: navigator.sendBeacon en visibilitychange/pagehide para flush.
    -- Retransmisión: cola local (memoria/localStorage) y reintentos con backoff.
    -- Correlación: incluir requestId/traceId si tu backend lo devuelve en headers.
  - Patrones de implementación mental (checklist rápido)
    -- Pregunta → dato: “¿Qué decisión habilita este dato?”
    -- Dato → fuente: “¿sale del usuario, del navegador o del estado de la app?”
    -- Fuente → riesgo: “¿puede incluir PII/secretos?”
    -- Riesgo → control: “allowlist/scrub/sampling/consent”
    -- Control → contrato: “esquema estable + versión”
    -- Contrato → transporte: “batch + retry + beacon + dedupe”

+ Capturar telemetría en Next
  - Router: page views (routeChangeComplete).
  - Acciones clave: submit, enroll, search, checkout, “copied”, etc.
  - Errores comunes:
    -- Frontend: window.onerror, unhandledrejection, Error Boundaries.
    -- API client: interceptores (fetch/axios) para latencia/códigos.
    -- Performance: Web Vitals (reportWebVitals en Next) + tiempos de API.

+ Mejores prácticas en telemetría (Guardrails)
  - Consent-first: no enviar analítica si consent.analytics=false.
  - Redacción/sanitización: no mandar inputs libres (comentarios, textos) sin scrub.
  - Allowlist de propiedades: solo claves permitidas (evita fuga accidental).
  - Sampling: performance/verbose logs con muestreo (p.ej. 10%).
  - Ambientes: dev vs prod (no mezclar).

### Thinking Framework

#### Thinking Development
- Por qué es importante la telemetría
- Planificar la implementación de la telemetría al inicio del desarrollo y no como idea de último momento
- Intencionalidad de los datos
- “lo mínimo útil”
- Privacidad por defecto: evaluar sensibilidad de los datos antes de implementar
- capturar lo necesario para entender “qué pasó” sin necesidad de ver el código o preguntar al usuario
- calidad analítica: definir eventos que midan valor real (funnel, activación, retención).

#### Best Practices
- Nunca activar la telemetría de análisis sin el consentimiento explícito del usuario
- Definir conjuntos de datos delimitados y evitar fuga de datos adicionales.

#### Patterns
- Event envelope estándar: event + timestamp + user/session + context + properties + schemaVersion.
- Taxonomía de eventos: convención clara (p.ej. screen_viewed, cta_clicked, form_submitted, api_failed).
- Propiedades con allowlist: lista explícita de keys permitidas por evento (bloquea fugas).
- Batch + flush: cola local, envío por lotes, sendBeacon en salida y reintentos con backoff.
- Correlación: sessionId + requestId/traceId para unir frontend–backend–logs.
- Consent gating: capa única que decide si se trackea y qué (analytics vs functional).
- Sanitización sistemática: scrub de URLs, query params, headers, y bloqueo de texto libre salvo casos justificados.
- Errores con fingerprints: agrupar por errorCode/fingerprint y adjuntar breadcrumbs limitados.
- Sampling: performance y verbose events muestreados; críticos al 100%.
- Schema versioning: cambios incompatibles → nueva versión o evento nuevo.

#### Anti-patterns
- “Loggear todo”
- datos sensibles en eventos: emails, teléfonos, nombres, tokens, comentarios, payloads completos.
- Eventos sin propósito: “click” genérico sin where/what/why → datos inútiles.
- renombrar eventos/propiedades cada sprint
- Mezclar perfil con telemetría
- Contexto inconsistente: rutas sin normalizar, timestamps locales, timezone omitida.
- Capturar en componentes a lo loco: tracking disperso, duplicado y difícil de mantener.
- Texto libre sin control en lugar de cumplir un contrato
- No respetar consentimiento sobre la trazabilidad

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 35

### Content

Skill 30: Anwsering front end telemetry requests

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 35

**Status:** Approved

### Content

- Data and telemetry has become more and more important, we need to collect and process telemetry
- Batch vs stream
      - Processing a stream (atomic activity)
      - Procesing a batch (big chunks)
- Throttling 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 36

### Content

Skill 31: Manejar datasets con Pandas

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 12 — Day 36

**Status:** Approved

### Content

> Teoría: (Reutilizar contenido de Data Science)
  + Introducción a Numpy

  + Manejo de datasets con Pandas
    - Observabilidad, Introspección, Acumulación, 
    - Nuevas columnas
    - Datos nulos
    - Limpieza y reporte

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No loops, solo acumuladores

## Week 12 — Day 36

**Status:** Approved

### Content

> Prácticas de numpy y pandas creadas en DS.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 37

### Content

Skill 32: Building a report from the telemetry or user data

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 37

**Status:** Approved

### Teoría

- Construyendo el report a partir de un cronjob (introduccion a background processing)
- Introduccion a data pipelines (el pipeline de datos mas sencillo de todos)
-  Modificar los datos que teniamos almacenados precariamente en el backend y montar un reporte, por ejemplo: cuantos TODOs completa el usuario semanalmente por día. 
- Agregación, agrupamiento y métrica

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 38

### Content

Skill 33: Background processing

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 38

**Status:** Approved

### Content

General concepts:
       - Background processing is better done if we assign status to the data chunk that is being procesed

Triggers for background processing:

- User triggered background processing
- Telemetry (or machine) triggered backgorund processing
- Cronjob triggered backgorund processing
- 3rd part triggered background processing
- Chained processing (internal workflow or data pipeline)
- Observability : poder saber lo que pasó
- Durability: que la "función" no se detenga en su ejecución, si no cuando deba detenerse. 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 17 — Day #REF!

### Content

Docker

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 39

### Content

Skill x: Predictions Model 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 13 — Day 39

**Status:** Approved

### Content

- Entrenamiento de un clasificador (predice una categoría)
- Regresión (predice un número) 

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 14 — Day 40

### Content

Building a data pipeline for create a dataset for an LLM or ML Model to use

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 14 — Day 40

**Status:** Approved

### Content

0. Collect
Create a source scrapping, api fetching, mining, etc.

1. Ingest

Bring data from a source into the pipeline.
Patterns: batch, streaming, file drops.

2. Transform

Modify data so it becomes useful.
Includes: cleaning, validation, normalization, enrichment, deduplication, business rules.

3. Load

Persist the transformed data into a target system.
Targets: lake, warehouse, analytics DB, feature store.

4. Orchestrate

Coordinate the steps and define dependencies.
Includes: scheduling, DAGs, retries, notifications.

5. Monitor

Track health, quality, freshness, and failures.
Includes: metrics, lineage, alerts, SLAs, anomaly detection.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_
