# Syllabus (Clean Extract)

## Week 0 — Day -6

### Content

Prework -
Skill 0.1: Familiarizarse con la plataforma de 4Geeks
Skill 0.2: Comprender cómo funciona internet

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -6
**Status:** Aprobado

### Teoría

+ Introducción a 4Geeks Academy
    - Importancia del prework (crear nuevo)
    - Intro a la plataforma de 4Geeks.com (crear nuevo)
    - Breve intro a Github como perfil profesional en tecnología
        - Importancia de conectar la cuenta de Github con la plataforma de 4Geeks.com
+ Herramientas a tu disposición en 4Geeks Academy
    - Intro a Slack
    - ¿Qué es LearnPack?
    - ¿Qué es Rigobot?
    - ¿Qué es Github Codespaces?
+ Consejos para estudiar con éxito en 4Geeks
    - ¿Cómo aprovechar al máximo el curso?
    - ¿Cómo pedir ayuda?
+ La Internet
    - ¿Qué es internet?
    - Funcionamiento: HTTP y sus verbos (GET, POST, PUT/PATCH, DELETE), Cliente - Servidor
    - Navegadores
    - Cómo funciona una web: frontend, backend - APIs, bases de datos, llamadas a APIs
(HTTP)
- Cómo se transmite una solicitud por Internet

### Thinking Framework

#### Thinking Development
- Aprender cómo aprender en 4Geeks
- Conocer los componentes principales del
- proceso de aprendizaje en 4Geeks
- Conocer los medios y mecanismos para solicitar
- y obtener ayuda en 4Geeks
- Saber entregar proyectos en 4Geeks usando Git
- y Github
- Concientizar la necesidad del hábito de leer y
- atender a los detalles

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
- No pedir ayuda
- No investigar
- Esperar a que todo me lo expliquen
- No usar los canales de
- comunicación

#### Constraints & Limitations
- No IA

## Week 0 — Day -5

### Content

Prework -
Skill 0.3: Conocer los fundamentos de HTML, CSS y Git para entregar un primer proyecto

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -5
**Status:** Aprobado

### Teoría

+ Introducción a HTML y CSS (Se dejará lo actual)
+ ¿Cómo entregar tus proyectos en 4Geeks?
(Esto ya existe pero requiere revisión: mejorar organización)
- Breve reseña sobre GitHub y Git, de forma poco técnica
- (Esto no existe) Esenciales de Github y Git para entregar proyectos
-- git add, git commit, git push

### Thinking Framework

#### Thinking Development
- Entender flujos (http es movimiento de
- información y hay un objetivo para ese
- movimiento, un flujo). Esto incluye , git, internet,
- algoritmos, etc.
- Comprender los principales componentes de la
- comunicación en Internet
- Conocer los principales elementos de un sitio
- web
- Familiarizarse con algunos de los principales
- conceptos del programa de estudios

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 0 — Day -5
**Status:** Aprobado

### Proyecto

- Postcard (entregada en un repo)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -5
**Status:** -4 y -3

### Content

Prework -
Skill 0.4: Conocer y aplicar los fundamentos de la programación

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -5
**Status:** Aprobado

### Teoría

+ Introducción a la programación (Javascript) (Referencia rápida a los conceptos)
    - Pensamiento lógico-matemático
    - Algoritmos
    - Variables
    - Condiciones
    - Bucles
    - Cómo representar listados en JavaScript (Arrays)
    - Cómo objetos en JavaScript (Literal Objects)

### Thinking Framework

#### Thinking Development
- Pensamiento lógico - matemático, algoritmos.
- Concientizar la necesidad del hábito de leer y
- atender a los detalles
- Reconocer la importancia de desarrollar la
- autonomía en la resolución de problemas

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- Plantear la solución antes que el código
- Divide y venceras. Dividir un problema
- grande en subproblemas más pequeños
- del mismo tipo, resolver cada uno, y
- luego combinar las soluciones.
- Clean code

#### Anti-patterns
- Algoritmos:
- Fijación en la Sintaxis: Centrarse
- únicamente en recordar la sintaxis del
- lenguaje de programación antes de
- tener una lógica clara.
- Pensamiento lineal: Intentar escribir
- toda la solución de una vez, de
- principio a fin, sin planificación.
- Aplicar correacciones por reacción a
- lo que aparece en la consola y no por
- análisis del código
- Test de Único Caso. Probar el
- algoritmo solo con el caso de ejemplo
- proporcionado, sin considerar casos
- límite (vacíos, negativos, máximos) o
- casos de borde.

#### Constraints & Limitations
- No IA

## Week 0 — Day -5
**Status:** Aprobado

### Práctica

- Beginner JS (nuevo)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -2

### Content

Prework -
Skill 0.5: Comprender cómo funciona la IA Generativa y los principales modelos z
Skill 0.6: Conocer los distintos formatos para comunicarse con la IA Generativa

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -2
**Status:** Aprobado

### Teoría

+ Introducción a la IA generativa
    - ¿Qué es un LLM?
    - ¿Y cómo funciona la IA?
    - ¿Cuáles son las principales opciones (OpenAI ChatGPT, Google Gemini, Anthropic
Claude, xAI Grok, Mistral LeChat...)?
- Diferencias: Ventajas y desventajas entre modelos
+ Hablar en el lenguaje de la IA:
    - Markdown
    - JSON
    - YML
    - TOON (nuevo formato, potencial de convertirse en tendencia)

### Thinking Framework

#### Thinking Development
- Entender cómo funciona los modelos de IA
- generativa
- Desarrollar criterio para escoger entre un
- modelo u otro
- Comprender cómo desarrollar un buen contexto
- para la IA
- Reconocer la importancia de desarrollar la
- autonomía en la resolución de problemas

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
- Tratar a todas las IAs por igual
- Escribir sin estructura ni formato

#### Constraints & Limitations
- No IA

## Week 0 — Day -2
**Status:** Proyecto
pendiente
evaluación

### Práctica

- Escribir una configuración en YML y JSON

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1

### Content

Prework -
Skill 0.7: Conocer qué son los Coding Agents y cómo funcionan
Skill 0.8: Conocer los fundamentos de la AI Engineering

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1
**Status:** Aprobado

### Teoría

+ Using Coding agents
    - ¿Cómo funciona la IA en desarrollo?
    - Configuración básica de Coding Agent en Github Codespaces
    - Herramientas más conocidas: https://agents.4geeks.com/
    - Using LLMs
    - Token consumption, pricing, parameters
+ Fundamentos del AI Engineer
    - Programación asistida con IA
    - Human in the loop / Humanos en el proceso
    - Camino de menor resistencia

### Thinking Framework

#### Thinking Development
- Entender cómo funcionan los Coding Agents
- Desarrollar criterio para escoger entre un
- modelo u otro
- Comprender cómo desarrollar un buen contexto
- para la IA
- Concientizar la necesidad del hábito de leer y
- atender a los detalles
- Reconocer la importancia de desarrollar la
- autonomía en la resolución de problemas

#### Best Practices
- Iterar vs crear de nuevo:
- vibecoding manifest
- https://vibemanifesto.org/

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 0 — Day -1
**Status:** Aprobado

### Proyecto

+ Proyecto final: Excuse generator para imprimir por consola
1. Pedir a Copilot que cree un fichero JS
2. Pedir a Copilot que cree un array de quién
3. Pedir a Copilot que cree un array de acción
4. Pedir a Copilot que cree un array de qué
5. Pedir a Copilot que cree un array de cuándo
6. Pedir a Copilot que genere una línea de código para obtener un valor aleatorio del
array quién, otro valor aleatorio del array acción y otro del array qué y el array cuándo
7. Pedir a Copilot que concatene todos los valores obtenidos con un espacio en blanco
de por medio y lo inserte en una variable
8. Pedir a Copilot que inserte un console.log para imprimir el valor de la variable en
la terminal.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No se imprime por html para reducir la
- complejidad con el tema del DOM, que
- los estudiantes se ponen a investigar
- porque no entienden por qué esos
- comandos

## Week 0 — Day -1
**Status:** Aprobado

### Content

INICIO DEL CURSO

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 1

### Content

Skill 1: Desarrollar interfaces sencillas con HTML y CSS cumpliendo con normas de
accesibilidad y princpios de SEO/GEO

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 1
**Status:** Approved

### Content

- Se dan 30 minutos de repaso de prework
- Coding Agents
- Fundamentos de AI Software Engineer
> Teoría (30 minutos):
+ HTML
    - Principales etiquetas
    - HTML semántico y contextual
    - Buenas prácticas
+ CSS
    - Flexbox
    - DRY en CSS
    - Selectores avanzados
    - Buenas prácticas
+ Accesibilidad web
    - Principios
    - Etiquetas principales (aria-label y role)
    - Principales problemas de accesibilidad
+ SEO y GEO
    - Schema.org

### Thinking Framework

#### Thinking Development
- Reconocer una interfaz y saber rapidamente en
- que cajas se va a dividir.
- Poder seleccionar un elemento del DOM

#### Best Practices
- Uso de tags generales ✅
- DRY ⚠
- Uso de html contextual
- (section, footer, header, head,
- body, atributo 'alt') ⚠
- SEO/GEO (schema org) ⚠
- Accesabilidad (principios, aria-
- label, alt...)⚠

#### Patterns
- Flexbox
- Semantic HTML
- BEM Methodology
- Mobile First

#### Anti-patterns
- display: inline-block
- float

#### Constraints & Limitations
- No hay backend
- No hay javascript
- Especificamente pedirle a la ia que no
- queremos plantilla
- Usar un modelo viejo como sonnet 3.5

## Week 1 — Day 1
**Status:** Approved

### Content

> Proyecto 1: "Un AI Engineer requiere mostrar sus habilidades"
0. Contexto: Decides lanzarte al mundo de la AI Engineering y necesitas darte a
conocer. La mejor forma de hacerlo: construir un sitio web para mostrar tu talento. Estás
empezando, por lo que harás una versión inicial que más adelante podrás hacer crecer. ¡Da
lo mejor de ti! No por ser lo primero tiene que tener poca calidad. ;-)
La entrega debe tener un markdown llamado PROMPTS.md con todos los prompts utilizados
para el resultado
Indicar los requisitos (HTML, CSS, Accesibilidad y Schema.org)
> Instrucciones al profesor:
- Este curso solo puede tener HTML y CSS, incluyendo etiquetas de Accesibilidad
- Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su
resultado
- HTML y CSS deben quedar en archivos separados.
- Crear un único documento HTML con distintas secciones: Bienvenida, sobre mí, mi
trabajo y contacto
- No permitir que se use un único prompt para hacer todo el ejercicio
- Asegurar el cumplimiento, con mejores prácticas de código y de diseño, etc.
> Propuesta para guiar el ejercicio:
- Se deben incorporar elementos poco a poco (el body, luego una barra superior, luego
un logo a la izquierda y una lista de enlaces a la derecha)
1. Se pide (de forma vaga, sin detalle, aunque limitado para que no resuelva todo el
proyecto) a la IA que haga una web personal de AI Engineer con solo HTML y CSS.
2. Se revisa el código.
3. Se pide que haga una nueva versión, refinando la solicitud, y se le pasa pasa la
foto.
4. Se revisa el código resultante.
5. Se contrasta con lighthouse (disponible en crhome y brave de forma nativa). Se pulen
los puntos bajos
6. Se revisa el código "final"
7. Se analizan las diferencias entre las solicitudes y entre los resultados
+ Actividad extra (en caso de que el proyecto salga rápido):
    - Hacer que la vista sea un Feed de Instagram, repitiendo la estructura del post con
distintas imágenes y texto.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 2

### Content

Skill 2: Desarrollar interfaces complejas utilizando librerías de CSS en lugar de CSS y
reconociendo los componentes más comunes utilizados en un website

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 2
**Status:** Approved

### Teoría

+ Web app layouts
    - ¿Qué es el layout?
    - Formas de navegación: Sidebar, topbar, bottombar, etc...
    - Todos los tipos de diagramación de vistas y contenido en una sola página
    - Introducción al diseño compuesto (old atomic desing) aplicado a web: átomos,
moléculas, organismos, plantillas, páginas
+ Componentes web
    - Elementos típicos para representar tus datos (card, modal, toggle, dropdown)
    - Listados de elementos: Tablas, acordión, lista de cards, cards desplegables, widget
box.
+ Diseño responsivo
    - ¿Qué es el diseño responsivo?
    - ¿Por qué es importante que el contenido se adapte a cada tipo de pantalla?
    - Principales pantallas: Móvil, Tablet, Portátil, Monitor o TV
    - ¿Cómo se gestiona el diseño responsivo? media queries vs bibliotecas CSS
(referencia genérica, se puede usar ejemplo con Tailwind)
- Mobile-first design
+ Tailwind
    - Ask Rigobot: ¿Qué es un CDN?
    - Ventajas de usar una biblioteca de estilos
    - Situaciones comunes: ir sobre casos de uso (spacing: padding y margin, sizing:
width, height..., overflow y scrolling, posicionamiento de elementos)

### Thinking Framework

#### Thinking Development
- Saber identificar componentes en función del
- diseño (Pensar en interfaces de usuario con
- piezas reutilizables)
- compositional thinking: la idea es que el
- desarrollador vaya del macro al micro,
- empezando por el componente más externo
- hasta el más específico
- Iteración top-bottom con IA: de la estructura
- principal a las características, terminando con
- colores y tipografías
- Describir conceptualmente y no visualmente
- Reconocer componentes en una interfaz
- Identificar qué elementos cambiar según el
- dispositivo

#### Best Practices
- Using CDN
- Style normalization (https:
- //tailwindcss.com/docs/preflight)
- Responsive Breakspoints at
- least 3 devices (phone, portrait
- tablet, desktop)
- Mobile-first design
- Rows vs Columns
- Flex vs GRID ⚠
- Using tailwing utility classes

#### Patterns
- Componentes reutilizables
- Section based architecture
- Slot and layout pattern
- Prompt as pattern: Generate a
- [section_type] using [framework].
- It should include [key elements]. Follow
- the [theme] and use Tailwind utilities for
- spacing and alignment.
- Mobile pattern

#### Anti-patterns
- Pixel based thinking (e.g.: button de
- 30px)
- Single prompt page generation
- Ignorar la jerarquía de los
- componentes
- Overstyling / Estilos excesivos
- Hacer componentes muy
- específicos en lugar de reutilizar
- anteriores

#### Constraints & Limitations
- Usar un modelo viejo como sonnet 3.5

## Week 1 — Day 2
**Status:** Proyecto
pendiente
aprobación

### Proyecto

Contexto: En el mundo tech, una forma de aprender a hacer cosas es replicar a las
referencias de Internet. En esta ocasión te proponemos que hagas una réplica de Kick el
nuevo competidor de Twitch, y para facilitar tu trabajo incorporarás Tailwind (Adjuntar
capturas PC, Tablet y Móvil que hizo Marco)
1. Se pide a la IA que haga una réplica de Twitch con Tailwind, solo HTML y CSS
2. Se revisa el código
3. Si no resulta satisfactorio el resultado, se refinan detalles con la IA
(describiendo las dos vistas en detalle)
4. Se revisa el resultado y se evalúa el cumplimiento de mejores prácticas y patrones
en el código
5. Pedirle a la IA que haga que desde la barra de navegación se pueda cambiar el tipo
de visualización
+ Actividades extra:
    - Refinar los elementos de la vista para que se parezcan más a Instagram
    - Agregar efectos visuales avanzados y animaciones
> Instrucciones al profesor:
- Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su
resultado

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- Usar Tailwind CSS sin bibliotecas de
- componentes como ShadCN

## Week 1 — Day 3

### Content

Skill 3: Desarrollar formularios complejos pero con interacciones sencillas, utilizando
bibliotectas de CSS + JS muy sencillo

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 3
**Status:** Approved

### Teoría

+ Formularios
    - Etiquetas principales
    - Inputs de texto (text, email, autocomplete)
    - Inputs de selección: radiobutton y checkbox
    - Otros inputs (numéricos, fechas...)
    - Textarea
    - Selects (y options)
    - Botones: input=submit vs button
    - Identificando y agrupando campos: Labels, placeholders y fieldgroups
    - Validaciones en formularios con navegador
    - Casos especiales: required, disabled, read-only
    - Casos de uso más comunes en formularios (login, contacto, búsqueda, registros,
compra)
+ Tailwind en formularios
    - Form layouts (login, inline, grid)
    - Elementos típicos para representar en tus formularios (alerts, form, modal,
dropdown, switch, toggle groups)
- Situaciones comunes Tailwind en forms (spacing y sizing, señalización de errores)
+ Flujos con formularios
    - Campos condicionados / interdependientes
    - Adaptive stepped forms
    - Formularios compuestos ("Modal para Creación de Dependencia")
    - Validaciones avanzadas (JS para formularios)
+ Buenas prácticas en formularios / Formularios efectivos (pocos datos)
    - Campos innecesarios:
        - Por redundancia (fecha inicio + fecha fin + duración)
        - Por pertinencia (dirección de casa para crear una cuenta de usuario)
        - Puede solicitarse en otro momento (pedir datos fiscales para crear una cuenta de
usuario)

### Thinking Framework

#### Thinking Development
- Identificar que informacion precisas
- Cosas que no tienes que aprender en este
- punto (entrañas de JS en la validación,
- condiciones de dependencia entre los
- formularios)

#### Best Practices
- Uso del correcto input type
- Uso del label y el atributo for
- Agrupar campos con un
- mismo propósito (fieldset y
- legend)
- Validación por defecto y
- campos requeridos
- Diagramación de formularios
- Consistencia Visual

#### Patterns
- utility-first
- Validación inmediata
- Patrones de diseño:
- Componentes de Campos de Entrada
- Contenedor de Grupos de Campos
- Mensajes de Alerta/Feedback

#### Anti-patterns
- no label / placeholder as a label /
- label confuso
- input type text para todo
- Campos innecesarios
- Formularios largos
- Ocultar los errores hasta el final
- No responsive

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 1 — Day 3
**Status:** Approved

### Proyecto

1. Se pide a la IA que haga un "portafolio" de un AI Engineer (Una landing como en el
Skill 1)
2. Se le pide a IA que incorpore una sección de contacto en la misma vista principal.
3. Indicar qué información es requerida/opcional
4. Revisar el resultado y verificar que los campos tienen los tipos adecuados
5. Solicitar a la IA un documento nuevo con un formulario de propuestas de proyectos
6. El formulario deberá tener al menos un campo nombre, un campo correo, un campo fecha
de entrega y un campo de texto largo.
7. Se pueden agregar campos opcionales como presupuesto disponible (campo numérico)
5. Revisar el resultado y buenas prácticas
6. Pedir a la IA validación de campos con VanillaJS para cada formulario
7. Verificar la correctitud de las validaciones y que los mensajes de error tienen
estilos adecuados
8. Agregar botón secundario para borrar formulario
> Instrucciones al profesor:
- Guiar el ejercicio y hacer que algunas personas compartan pantalla y muestren su
resultado
- Debe tener 2 "vistas" Una con el portafolio + el contacto y otra con el formulario de
cotización.
- Se deberá hacer un repositorio nuevo, no reutilizar el del dia 1, pueden reutilizar
los prompts

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 4

### Content

Skill 4: Utiliar la linea de comando para interacciones basicas en el dia a dia en la
vida de un desarrollador

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 4
**Status:** Approved

### Teoría

+ Sistema de archivos (Jerarquía)
    - Rutas relativas vs Rutas absolutas
    - Entry point
+ Command Line / Terminal
    - 10 comandos más usados por un programador (+ 1: incluir grep)
    - Editores de archivos más comunes: vi, nano (comandos principales: salida, edición y
escritura)
- Conexiones SSH

### Thinking Framework

#### Thinking Development
- Comprensión del sistema de archivos y su
- jerarquía
- ¿Dónde estoy cuando estoy en la Terminal?
- Cómo referenciar rutas desde mi ubicación
- Cómo ubicar un proceso en la estructura
- La raíz de un proceso no es la raíz del proyecto.
- Es la ruta del entry file (entrypoint)

#### Best Practices
- Uso de rutas absolutas antes
- que relativas
- Evaluar dónde estoy antes de
- intentar moverme en el sistema
- de archivos

#### Patterns
- navegación por directorios (\(cd\), \
- (pwd\))
- la gestión de archivos (\(ls\), \(cp\), \
- (mv\), \(rm\))
- la ejecución de comandos para
- interactuar con el sistema operativo

#### Anti-patterns
- Trabajar en modo root (superuser /
- admin)

#### Constraints & Limitations
- No IA
- No se creará un Shell Script, pero se les
- explicará en qué consisten

## Week 2 — Day 4
**Status:** Approved

### Content

> Proyecto 1: exercise-command-line-challenge (reemplazar https://cmdchallenge.com/)
> Proyecto 2 (a evaluar viabilidad):
- ¿Conectarse a un servidor remoto por SSH y encontrar un texto?
- Pedir a la IA que genere los comandos por nosotros

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 2 — Day 5

### Content

Skill 5: Git + Github => Aprender a trabajar colaborar y comandar una IA de forma
eficiente y con bajo riesgo

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 5
**Status:** Approved

### Teoría

+ Git para devs
    - Cómo funciona
    - Cómo saber dónde estoy (concepto de HEAD)
    - Principales comandos (git status, git add, git commit, git pull, git push, git
remote)
- Algunos comandos avanzados (git merge, git log [y --stat], git revert, git stash,
git reset)
- Gestión de cambios: Línea de comandos vs Interfaz del editor (IDE) vs hechos por IA
- Ramas (git branch, concepto de HEAD)
- Gitflow simplificado (main, dev, feature/, bugfix/) <--- Establecer lineamientos de
base para homologar entre profesores y evitar "ramas personales"
- git switch vs git checkout [y -b]
- git merge vs git rebase
- Buenas prácticas en Git
+ Github
    - ¿Qué es Github?
    - Issues
    - Forks vs Templates
    - Pull Requests (entre ramas y entre repos)
    - Buenas prácticas en Github

### Thinking Framework

#### Thinking Development
- Relacionar commits con características o
- funcionalidades
- Identificar los principales comandos de Git y su
- uso en el IDE
- Saber dónde estoy en un proyecto git
- Cómo moverme entre ramas
- Incorporar el uso de PR como mecanismo para
- incorporar funcionalidades/características por
- ramas
- Cómo colaborar o contribuir de forma
- organizada
- Como deshacer o revertir cambios

#### Best Practices
- Selección de archivos de un
- commit
- Una característica (vista, en
- este caso), una rama
- Hacer PR
- Mantener limpieza de ramas

#### Patterns
- Git por línea de comandos
- Git por IDE
- Gitflow (simplificado: trabajo con ramas
- principales y nomenclatura base)
- Partir de un core (main) y hacer PRs al
- core
- Configuraciones y claves fuera del
- repositorio
- ¿¿¿Fusionar ramas muy antiguas sin git
- rebase???
- ¿¿¿ Git rebase (es un patrón pero
- puede agregar complejidad) ???

#### Anti-patterns
- Uso del git add . o añadir todo al
- commit siempre
- Trabajo directo en main
- No describir adecuadamente los
- commits
- Commits muy grandes
- --force
- Subir los .env y configuraciones al
- proyecto
- PR sin revisiones
- Ignorar las peticiones de PR
- Alejandro Sanchez xD

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 5
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto colaborativo en pareja (Equipo + IA + Git): maquetación de una tienda estática
colaborativa con IA (Solo HTML y Tailwind)
1. Preguntar a la IA ¿Qué elementos básicos debe tener la maqueta de una tienda en
línea?
2. Validar la respuesta de la IA y analizar se se adecúa a lo que se busca
3. Distribuir tareas por características/vistas (crear el repo común y actividades)
4. Desarrollar características en ramas
5. Unificar desarrollos en rama principal
6. Conectar vistas (commits y merges adicionales)
Debe contener todo lo que se ha visto anteriormente (HTML semántico, Tailwind, Schema.
org, diseño responsivo) y conformarse por 5 vistas
- Home (con una barra de navegación, un Hero, listado de productos nuevos, listado de
productos más comprados, footer)
- Catálogo (listado de productos y barra de filtros)
- Producto (Foto de producto, detalles de producto, precio y descripción)
- Carrito (vista completa del contenido de un carrito con sus productos, la totalización
y botón de comprar)
- Formulario de pago (datos personales, dirección de entrega y datos de tarjeta)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- Solo HTML y Tailwind
- Nada de React.
- Puede haber alguna acción con JS

## Week 2 — Day 6

### Content

Skill 6: Representar y estructurar de forma determinista la lógica de un sistema usando
flujos secuenciales con contextos variables

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 2 — Day 6
**Status:** Approved

### Teoría

+ ¿Qué es la programación? -> Darle instrucciones a una máquina
    - Pensamiento Algorítmico -> Escribir en pseudocódigo.
    - Variables
    - Direcciones de memoria
    - Tipos de datos básicos o primitivos (character, integer, float, boolean)
    - Tipos de datos estructurados o complejos (mención superficial a cadenas de texto,
colecciones (arrays) y objetos)
- Operadores (aritméticos, de asignación, de comparación y lógicos) : versión simple
de cada uno.
+ Dominando el Flujo del Programa (Lógica de Programación y Control de Ejecución):
    - Control de flujo (condicionales) - Control flow
        - Identificación de casos borde/límite
    - Estado del flujo - State flow
    - Conceptos de iteración y bucles (for, while)
    - Scope / Contexto
    - Flujos anidados
    - Flujos reutilizables (introduccion teórica a "funciones")

### Thinking Framework

#### Thinking Development
- Pensamiento lógico / matemático.
- Ir de los específico a lo general: comenzar por
- las excepciones al construir el algoritmo.
- Saber diferenciar entre el crontrol flow y el state
- flow
- Saber predecir state flow (ejecución en frio)
- Identificar y evaluar los casos borde/límite de un
- problema
- Reducir los condicionales al mínimo: bifurcar es
- agregar complejidad
- Identificar el uso del concepto que se esta
- aprendiendo ( que el alumno comprenda "cuanto
- necesita entender" de un concepto para poder
- avanzar, por ejemplo para usar un taladro para
- colgar un cuadro no necesito comprender la
- electronica del mismo mientras que si lo que
- busco es mejorar el taladro si que requira
- comprender sus componentes y funcionamiento
- interno para esa tarea)
- Plantear soluciones en tu idioma nativo primero,
- luego pseudocódigo
- Comprender el próposito para alcanzar el
- objetivo
- Comprender que no necesito conocer y dominar
- todo para plantear una solución en pasos y
- procesos (pueden existir cajas negras)

#### Best Practices
- Analogías con el mundo real

#### Patterns
- El Patrón "Sándwich" (IPO: Input-
- Process-Output)
- Es la estructura fundamental. Todo
- algoritmo debe tener tres fases claras.
- Entrada (Input): Definir qué necesito
- (ingredientes). Inicializar variables
- (Contador = 0).
- Proceso: La lógica, cálculos y bucles.
- Salida (Output): Mostrar el resultado o
- devolver el valor.
- El Patrón de "Salida Única" (Single Exit
- Point)
- Idealmente, un algoritmo o una sub-rutina
- debe tener un solo punto de inicio y un
- solo punto de fin.
- El Patrón del "Centinela" (Para Bucles)
- Al diseñar bucles mientras (while) o
- repetir (for), debe existir una condición
- clara de parada controlada por una
- variable.
- Modularización (Sub-procesos)
- Cuando un diagrama de flujo se hace
- muy largo, se debe colapsar una sección
- lógica en un "Proceso Predefinido"
- (generalmente un rectángulo con barras
- laterales).

#### Anti-patterns
- El Flujo Espagueti (Unstructured
- Jumps)
- El uso indiscriminado de flechas que
- cruzan todo el diagrama para volver a
- un punto arbitrario anterior (el
- equivalente al temido GOTO).
- El "Paso Milagro" (The Miracle Step)
- Un paso en el algoritmo que es
- demasiado ambiguo o complejo para
- ser una sola instrucción.
- El Bucle Infinito Visual (The Black
- Hole)
- Un ciclo donde las flechas de "No" o
- "Sí" vuelven al inicio del ciclo, pero
- ninguna acción dentro del ciclo
- cambia la condición.
- Código Muerto (Unreachable Code)
- Partes del diagrama o algoritmo a las
- que es imposible llegar porque la
- lógica anterior las excluye.

#### Constraints & Limitations
- No IA

## Week 2 — Day 6
**Status:** Proyecto
pendiente
aprobación

### Práctica

- Learnpacks Con múltiples retos de diseños de flujo y "state machine" (ejercicio tipo
los del Command Line) para validar que lo hagan correctamente

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 7

### Content

Skill 7.1: Entender los fundamentos de TypeScript, su sintaxis y cómo aplicar el concepto
de algoritmos en Typescript

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 7
**Status:** Approved

### Teoría

+ Fundamentos de Javascript y Typescript:
    - ¿Qué es JavaScript?
    - ¿Qué es TypeScript?
        - Relación entre JS y TS (JS vs TS)
        - ¿Cómo funciona TS?
    - ¿Cómo se escribe código en TS?
        - ¿Qué es la sintaxis?
        - Reglas principales de TS
    - ¿Para qué sirve el console.log()?
    - Variables (const, let, var)
+ Tipos de datos y operadores básicos de TS:
    - Tipos de Datos primitivos (number, boolean, string, symbol, null, undefined)
    - Operadores en JavaScript (aritméticos, asignación, comparación, lógicos) : versión
simple de cada uno.
+ Control de flujos en JavaScript y Typescript
    - Flujos simples: Condicionales (if, else if, else, switch)
    - Flujos repetitivos: Bucles
        - for
        - while
        - for..in, for..of y do-while como referencias adicionales
        - interruptores de flujo: break (para cortar la ejecución) y continue (para saltar
esta iteración)
-- Bucles anidados

### Thinking Framework

#### Thinking Development
- Convertir soluciones de pseudocódigo a la
- sintaxis del lenguaje.
- Aprender a investigar siempre que sea
- necesario. (memorizar no es una habilidad a
- desarrollar, se dará con la práctica)
- Identificar cuándo se hace uso de una palabra
- reservada.
- Aprender a identificar tipos de datos por su valor
- (su composicion).
- Comprender las diferencias de los tipos de
- datos
- Identificar los casos de uso de cada tipo de dato
- Escribir una instrucción por línea. Usar punto y
- coma ; (aunque sea opcional, para enseñar
- disciplina).

#### Best Practices
- Escribe el codigo, no lo copies
- Identacion

#### Patterns
- lowerCamelCase
- Logs Etiquetados: console.log("El valor
- de x es:", x)
- Const-First: Usar const por defecto, y let
- solo si el valor va a cambiar.
- Nombres Semánticos
- Igualdad Estricta

#### Anti-patterns
- Buscar la sintaxis perfecta.
- Usar código mágico (copiar y pegar,
- no tener concimiento de lo que hace
- código)
- Inconsistencia en la sintaxis (no
- mantener decisiones anteriores en
- estructura, patrones, etc)
- Crear bucles infinitos
- Condiciones kilométricas
- Arrow Code / Hadouken: if dentro de
- if dentro de if... formando una flecha a
- la derecha.

#### Constraints & Limitations
- No IA

## Week 3 — Day 7
**Status:** Proyecto
pendiente
aprobación

### Content

> Prácticas:
- Learnpack con con varios códigos generados por IA para revisar y corregir o aprobar.
- Learnpack (aparte del Beginner TS) orientado a condicionales y flujos llegando a una
mayor dificultad que el Beginner JS (aquí podrían estar Beatles, Bottles of milk...)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 8

### Content

Skill 7.2: Aprender a nombrar/etiquetar los flujos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 8
**Status:** Approved

### Teoría

+ Funciones en Javascript y Typescript
    - ¿Qué es un bloque de código?
    - Dar nombre a un bloque de código (creando una función)
    - Párametros (cómo pasar valores a una función)
    - ¿Cómo devuelve valores una función? (funcionamiento del return y especificación del
tipo de dato devuelto)
- Métodos vs funciones vs procedimientos (funciones que devuelven valor y funciones
que no)
- Métodos y funciones para trabajar con datos primitivos (string, number, etc)

### Thinking Framework

#### Thinking Development
- Desarrollar un flujo si hay un objetivo solo, que
- son:
- Mutar un valor de un proceso global
- obtener un valor y retornarlo
- Reconocer los valores que necesita mi funcion
- para lograr su objetivo
- Reconocer el tipo de funcion que requiero
- Mantener el principio de responsabilidad única

#### Best Practices
- Escribir funciones en sus
- diferentes versiones
- Leer un código existente y
- reescribirlo en funciones
- Console.log tu mejor amigo
- Usar variables en vez "código
- cableado"
- Leer errores

#### Patterns
- DRY
- Return Early (Cláusulas de Guarda)
- Funciones Puras (Concepto): La función
- debe trabajar solo con lo que recibe en
- sus parámetros ((a, b)).
- Single Responsibility (SOLID): Una
- función hace UNA sola cosa y la hace
- bien (calcularIva()).

#### Anti-patterns
- God Function: Una función que
- calcula, imprime, guarda y valida.
- Dependencia Global: Usar variables
- que están fuera de la función sin
- pasarlas como argumentos.

#### Constraints & Limitations
- No IA

## Week 3 — Day 8
**Status:** Approved

### Content

> Sólo práctica:
- Learnpack con varios códigos con funciones (con y sin parámetros, con y sin
devolución de resultado) y sus llamadas generados por IA para revisar y corregir o
aprobar.
- Mastering JS (adecuarlo explicando que es un learnpack que usará a lo largo de todo
el contenido de JS y que conforme avancen las clases irá aprendiendo a solucionar más
problemas)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 3 — Day 9

### Content

Skill 8.1: Manipular datos estructurados de tipo colecciones: transformándolas,
recorriendolas y buscando informacion de forma óptima

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 3 — Day 9
**Status:** Approved

### Teoría

+ Arreglos/Colecciones de elementos (arrays)
    - ¿Qué es un array?
    - ¿Cómo definir un array? (Sintaxis)
    - ¿Cómo acceder a posiciones en un array? ¿Cómo agregarlas o eliminarlas?
    - ¿Cómo recorrer un array? (for o while)
    - Principales métodos para recorrer arrays
    - ¿Qué es una matriz? (Arrays de arrays)
    - ¿Cómo acceder a las posiciones de una matriz? ¿Cómo agregar o eliminar posiciones?
    - ¿Cómo recorrer una matriz?
+ Ordenamiento y búsqueda en arrays
    - Ordenamiento de arrays con .sort() (con Botón Ask to Rigobot "What are the Sorting
Algorithms")
- Búsqueda lineal o secuencial en un array (Arrays desordenados - Métodos .find() e .
includes())
- Búsqueda eficiente en un array ordenado (Algoritmo de búsqueda binaria)
- Búsqueda en matrices

### Thinking Framework

#### Thinking Development
- Defnir y gestionar un array
- Definir y gestionar matrices
- Diferenciar arrays y matrices
- Entender cuando un elemento es iterable
- Buscar elementos en un array
- Buscar elementos en una matriz
- Ordenar arrays

#### Best Practices
- Aprender a gestionar arrays
- con bucles y con métodos del
- lenguaje.
- No memorizar. Investiga cada
- que necesites usar un método

#### Patterns
- Reasignación Explícita: texto = texto.
- toUpperCase() o guardar en nueva
- variable: const grito = texto.
- toUpperCase().
- Homogeneidad en arrays/colección
- Usar sintaxis literal > [ ]
- Iterar copia o Inversa

#### Anti-patterns
- Chaining Infinito: Encadenar 5
- métodos sin saber qué devuelve cada
- uno: str.split().reverse().join()....
- El Cajón de Sastre: listas con varios
- tipos de datos.
- new Array()
- Mutación durante iteración
- Hardcoding del límite (en bucles for
- para arrays)
- Acceso: Usar array[100] sin
- verificar el tamaño. Devuelve
- undefined y rompe operaciones
- posteriores.

#### Constraints & Limitations
- No IA

## Week 3 — Day 9
**Status:** Proyecto
pendiente
aprobación

### Práctica

- Mastering JS (ejercicios con Arrays)
> Proyecto 1: Gestor de butacas de cine
- Crear una matriz de butacas con ocupadas (1) y libres (0)
- Visualizar la sala imprimiendo la matriz con L (libre) y X (ocupado)
- Poder reservar un asiento (marcarlo con 1)
- Contar cuántas butacas están llenas y cuántas están vacías
+ Actividad extra:
    - Buscar asientos contiguos para parejas (dos personas)
> Proyecto 2: Almacén inteligente:
- Crear un listado de ids de paquetes que siempre esté ordenado
- Agregar nuevos paquetes (y reordenar)
- Verificar si un paquetes está en el listado por búsqueda binaria
+ Actividad extra:
    - Filtrar y eliminar paquetes "viejos" menores a un id de paquete

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 4 — Day 10

### Content

Skill 8.2: Modelar datos estructurados de tipo objeto

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 10
**Status:** Approved

### Teoría

+ Objetos:
    - Concepto de modelos vs objetos
    - Propiedad vs Valor
    - Métodos (propiedades que son funciones)
    - Combinación de tipos de Datos:
        - Ej: array de objetos, objetos anidados
+ Modelado de objetos mediante diagramas de clases

### Thinking Framework

#### Thinking Development
- Aplicar el concepto de abstración para
- representar objetos del mundo real en modelos
- Entender la diferencia entre un modelo y un
- objeto
- Entender la diferencia entre una propiedad y un
- valor
- Diferenciar entre una propiedad y método
- Identificar relaciones entre objetos

#### Best Practices
- El modelo debe partir desde lo
- más general

#### Patterns
- Mantener los modelos lo más general
- posible
- Schema Uniforme: Mantener la
- estructura de los objetos

#### Anti-patterns
- Objetos "Copo de Nieve": Crear
- objetos que deberían representar lo
- mismo (ej: usuarios) pero con
- estructuras diferentes.
- { nom: "Ana" } vs { nombre: "Juan" }.
- Relaciones circulares entre
- modelos/clases

#### Constraints & Limitations
- No IA

## Week 4 — Day 10
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1:
1. Usando `https://online.visual-paradigm.com/app/diagrams/#diagram:
proj=0&type=ClassDiagram` modela "Un reproductor de Playlist de Música" como Spotify,
donde las canciones son objetos individuales que viven dentro de una lista.
2. Se debe colocar los tipos de datos a las propiedades.
3. Debe tener al menos 5 modelos.
4. Se debe indicar qué modelos se relacionan entre sí.
5. Exporta el resultado en PNG para entregar
> Proyecto 1:
1. Usando https://online.visual-paradigm.com/ modela "Una billeta digital" como Wise,
donde exista un historial de movimientos.
2. Se debe colocar los tipos de datos a las propiedades.
3. Debe tener al menos 3 entidades.
3. Se debe indicar qué modelos se relacionan entre sí.
4. Exporta el resultado en PNG para entregar

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 11

### Content

Skill 8.3: Trabajar con datos estructurados de tipo objeto en TypeScript

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 11
**Status:** Approved

### Teoría

+ Representación de objetos en TS:
    - Interfaces vs Objetos literales
    - Sintaxis
    - Atributo vs Valor
    - Acceso a propiedades
    - Notación punto (nombre.atributo) vs Notación corchete (nombre['atributo'])
    - Operador "opcional": nombre?.atributo
    - Métodos
    - Manipulación de objetos
    - Combinación de tipos de Datos:
        - Ej: array de objetos, objetos anidados
+ Mutaciones (ej real: un libro -inmutable- vs un cuaderno -mutable- )
    - Paso por referencia vs paso por valor
    - Tipos de datos que admiten pasos por referencias o por valor

### Thinking Framework

#### Thinking Development
- Representar el mundo real en objetos literales /
- clases
- Diferenciar un objeto de clase a un objeto literal
- Identificar cuando existe un "paso por
- referencia" y cuando es un "paso por valor"
- Construir y manipular objetos

#### Best Practices
- Si varias variables tienen
- relación entre sí (parecen
- atributos de algo más), estudiar
- la posibilidad de un objeto

#### Patterns
- CamelCase: { nombreUsuario: "Juan" }.
- Facilita el uso del punto (.
- nombreUsuario).
- Bracket Notation: Entender que si la key
- viene en una variable, es obligatorio usar
- corchetes: objeto[variable]
- Tipado correcto: { activo: true, edad: 25 }.
- Facilita operaciones matemáticas y
- lógicas después.
- Optional Chaining: Enseñar el operador
- ?.: usuario.direccion?.cp. (Si direccion
- falta, devuelve undefined en vez de
- romper todo).

#### Anti-patterns
- Atributos con espacios: { "nombre del
- usuario": "Juan" }. Obliga a usar
- sintaxis compleja ['...'] siempre.
- La confusión del punto: Intentar usar
- una variable como key con notación
- de punto: objeto.variable (busca
- literalmente la key "variable").
- Valores como texto: Guardar
- números o booleanos como strings
- innecesariamente: { activo: "true",
- edad: "25" }.
- Hardcoding repetitivo: Escribir
- manualmente 20 objetos literales.
- Asumir que un dato anidado existe

#### Constraints & Limitations
- No IA
- No se abordan la herencia ni el
- polimorfismo

## Week 4 — Day 11
**Status:** Proyecto
pendiente
aprobación

### Práctica

- Mastering JS (ejercicios de objetos)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12

### Content

Skill 9: Comunicarse efectivamente con la IA para la creación de interfaces

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12
**Status:** Approved

### Teoría

+ Estrategias en la comunicación con la IA (Context & Anatomy):
    - Context Engineering
    - Word efficiency
    - Anatomía de un Prompt de UI: Rol (Senior Frontend Dev), Stack (React +
Tailwind/Bootstrap), Restricciones y Contenido.
- Mención de skill 0.4 (Hablar el lenguaje de la IA) para refrescar los tipos de
formatos.
+ Convertir lo visual en especificaciones para la IA:
    - Introducción al "Vision-to-Spec": Cómo traducir un diseño visual (mental o imagen)
a especificaciones técnicas en lenguaje natural.
- Descomposición Visual (The Box Model Mental): Aprender a pedir "contenedores",
"filas", "columnas" y "grid" sin escribir CSS.
-- Mención de skills (0 - 3) - aplicadas a este contexto/skill.
+ El Proceso Constructivo:
    - Iteración Constructiva (The Painter’s Algo):
        - Estructura (Wireframe).
        - Contenido (Textos/Imágenes).
        - Estilizado (Colores/Espaciado).
    - Camino de menor resistencia
    - Feedback Loop: Cómo decirle a la IA que algo "se ve mal" usando la terminología
correcta (padding, margen, alineación).

### Thinking Framework

#### Thinking Development
- Desarrollar abstracción Espacial: Capacidad de
- ver una web (ej. Spotify) y no ver "música", sino
- ver: Sidebar (fixed) + Main Content (scrollable) +
- Player (sticky footer).
- Desarrollar pensamiento Declarativo: Pasar de
- pensar en "cómo hacerlo" (imperativo) a "qué
- quiero obtener" (declarativo).
- Entender que una Landing Page no es una sola
- instrucción, sino la suma de Navbar + Hero +
- Features + Footer. (Descomposición de
- Problemas)
- Entender que la calidad de la respuesta depende
- de la calidad de la restricción

#### Best Practices
- Mobile First (Mentalidad):
- Instruir al LLM para que el
- diseño sea responsive por
- defecto. "Asegúrate de que en
- móvil se vea en una columna y
- en desktop en dos".
- Atomic Design (Simplificado):
- Enseñarles a pedirle a la IA que
- separe el código en
- archivos/componentes
- pequeños si el output es muy
- largo.

#### Patterns
- El Patrón "Matrioshka" (Component
- Isolation) Nunca pedir la página
- entera de una vez. Pedir componente por
- componente, de afuera hacia adentro o
- por secciones.
- El Patrón "Role & Stack Priming"
- Definir el contexto técnico antes de pedir
- nada para evitar código "vanilla" o
- librerías obsoletas.
- El Patrón "Reference Injection" Si el
- modelo es multimodal (acepta imágenes),
- subir un screenshot. Si no, describir la
- estructura basada en una grilla.
- El Patrón "Dummy Data First" Pedir a
- la IA que hardcodee datos falsos (arrays
- de objetos) para visualizar la UI antes de
- conectar lógica real.
- El Patrón de Refinamiento (Drill-Down)
- Ir de lo general a lo específico (Layout ->
- Componentes -> Estilos finos).

#### Anti-patterns
- El "One-Shot Wonder" (La Bala de
- Plata): Intentar generar el clon de
- Airbnb completo (Home, Detail,
- Checkout) en un solo prompt gigante.
- El "Vague Designer" (Diseñador
- Vago) : Usar adjetivos subjetivos en
- lugar de técnicos.
- El "Frankenstein Stack": No
- especificar librerías, resultando en
- una mezcla de CSS puro, Bootstrap,
- estilos en línea y librerías raras.
- La "Lógica Prematura": Intentar
- programar la funcionalidad (ej.
- autenticación, base de datos)
- mientras se está diseñando la UI.
- Asumir que la IA sabe qué todo lo
- que has estado "hablando" durante
- todo el projecto (ej. librerías usaste
- hace 3 prompts).
- Escribir 4 párrafos de historia de la
- empresa que no afectan el código.
- (Desperdicia tokens y confunde la
- atención de la IA).
- El Prompt "Adivina": "Hazme una
- página bonita para una tienda".
- (Demasiada entropía, la IA alucinará
- estilos aleatorios).

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 4 — Day 12
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto con IA: Replicar una website con React
- Replicar la home de airbnb.com
- Recordar que debe ser mobile first
- Pedir que comience el proyecto con un archivo "readme.md" o un defecto un .txt que
contenga "el contexto" de la interfaz que desea construir.
- Preparar al alumno con un discurso sobre el motivo de usar un stack que aún no maneja
del todo, en esta caso React.
> Instrucciones para el profesor:
- Se evulará únicamente el resultado (no el código en sí), dentro de ello que sea
responsive, accesibilidad, html semantico.
- El profesor debe especificarles el stack
- Se evaluará el "readme.md" con el prompt o contexto inicial

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13

### Content

Skill 10: Implementar pruebas unitarias en Typescript

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13
**Status:** Teoría
pendiente
aprobación

### Teoría

+ Introducción al testing
    - ¿Por qué probar un código?
    - Tipos de pruebas más conocidas:
        - Pruebas unitarias
        - Pruebas de funcionales
        - Pruebas de integración
        - Pruebas de rendimiento
    - Introducción al TDD (Test-Driven-Development)
+ Unit testing en Typescript
    - Frameworks de testing más conocidos: Jest, Mocha/Chai, Vitest
    - Pruebas unitarias con Jest
    - Planificación de pruebas unitarias

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 13
**Status:** Proyecto
pendiente
aprobación

### Proyecto

- Se proveerá un código con funciones de un sistema en TS para que el alumno les genere
las debidas pruebas unitarias a cada proceso. Desde la instalación de jest.
- Se deben generar las pruebas por pasos, es decir, no se debe hacer uso de un único
prompt.
> Instrucciones del profesor:
-

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14

### Content

Skill 11: Construir un banco de memoria y reglas de contexto a partir de un código base
preexistente

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14
**Status:** Approved

### Teoría

+ ¿Qué son las reglas para una IA de programación?
    - Alcances de las configuraciones y reglas de contextos: User vs Project. ¿Qué reglas
son de preferencia personal y cuáles son de necesidad del proyecto?
- Aplicación de reglas: description, globs, alwaysApply
-- Eficiencia de tokens:
--- Ir de lo general a los especifico. Muchos contextos con pequeños.
--- Ir de los específico a lo general. Minímo contextos necesarios a la vez.
- Tipos de aplicación: Always, Auto Attached (pattern), Agent Requested (agent
decides), Manual (mention), LLM Oriented
+ Memory bank: Persistencia del conocimiento más allá del chat actual
    - ¿Qué es un banco de memoria? ¿Para qué sirve?
    - ¿Qué es el contexto del producto? Descripción general del producto y del negocio
para un mejor contexto de lo que se quiere desarrollar
- ¿Qué es el plan de implementación? ¿Cómo construirlo con la IA? ¿Cómo gestionarlo
con la IA?

### Thinking Framework

#### Thinking Development
- Comprender la importancia y funcionamiento de
- la jerarquía de reglas
- Controlar el uso de los contextos de aplicación
- de las reglas
- Saber crear y gestionar el banco de memoria
- https://www.anthropic.com/engineering/effective-
- context-engineering-for-ai-agents

#### Best Practices
- Usar Globs para reglas de
- formatos, utilidades y pruebas y
- agrupar por carpetas
- Mencionar ficheros
- Comprender la estructura
- actual del proyecto.

#### Patterns
- Crear un plan de implementación y
- luego señir el desarrollo a su ejecución
- Mantener un plan de implementación
- dinámico según las necesidades del
- proyecto
- Gestionar y mantener actualizado el
- banco de memoria
- Reglas claras, limitadas y específicas
- Agregar nuevas reglas en función de las
- necesidades repetitivas que se van
- identificando
- Contenidos curados y concretos, no
- ambigüedades o divagaciones
- Respetar las reglas del preexistentes del
- proyecto y sólo modifcar bajo consenso

#### Anti-patterns
- Desarrollar de forma imperativa
- (saltar el plan de implementación,
- dándole órdenes nuevas a la IA)
- Dictador Global: Sobreescribir
- reglas de proyecto o de equipo por
- preferencias personales
- Ser muy descriptivo y ambiguo en la
- definición de reglas
- Confianza ciega en la proactividad
- del agente
- Pegar conversaciones muy largas y
- difíciles de procesar.
- Crear un contexto únicamente
- técnico y omitir el negocio.
- Sobreescribir las reglas preexistente
- "solo porque no me gusta"

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto 1:
1. Desarrollar un proyecto agregando progresivamente reglas para que la IA trabaje mejor
> Proyecto 2:
2. Rehacer proyecto grande teniendo reglas preestablecidas.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 14
**Status:** Proyecto
pendiente
aprobación

### Content

INICIO DEL FRONT END

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15

### Content

Skill 12.1: Identificar y definir componentes de una aplicación web

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15
**Status:** Approved

### Teoría

+ Arquitectura de Single Page Applications (SPA) y Empaquetado.
    - Bulding or compiling your app
    - Build time vs Runtime
    - Arquitectura SPA (Single Page Application):
        - Juzgando una página web (múltiples páginas)
        - La ilusión de la navegación: Hashstring (#) vs Browser History.
+ Introducción Next.js
    - ¿Qué es un Componente Web (en React)?
    - ¿Qué es Next?
        - React vs Next
    - Organización del Proyecto: Estructura de carpetas: /pages (vistas) vs /components
(piezas) vs /layouts
- App Router: Folder and file conventions
- Top-level folders & files
- Routing Files
- Nested routes
- Route groups and private folders
- Metadata file conventions
- Renderizado del lado del cliente (CSR) vs del lado del servidor (SSR)

### Thinking Framework

#### Thinking Development
- Poder leer la estructura de archivos de un
- website con React y determinar si tiene mejores
- prácticas.
- Verificar que las rutas sean "url friendly" y
- "website taxonomi": pensar en como "agrupar" el
- website, por ejemplo, /product/id/1asfa-fgasf-
- afsasd-asd
- si no que sea producto/bateria-carro
- Pensamiento Estructural/Jerárquico: Diferenciar
- entre un componente que es una "Vista" (ej.
- Home.jsx) y uno que es un "Widget" (ej. Button.
- jsx).
- La Ilusión de la Persistencia: Comprender que al
- navegar en una SPA, el navegador no "refresca".
- El alumno debe mentalizarse en que está
- inyectando contenido dinámicamente, no
- cambiando de archivo HTML.
- Abstracción del Layout: Habilidad para identificar
- qué partes de la web son constantes (Navbar,
- Footer) y qué partes son dinámicas (Outlet).
- Poder estar familirizado/cómodo navegando el
- "codebase" del proyecto.

#### Best Practices
- Clean Routing: Definir las rutas
- en un archivo separado o
- claramente en el entry point, no
- esparcidas.
- Componentes Funcionales:
- Prohibido usar Class
- Components (la IA a veces
- recurre a ellos si aprendió de
- datos antiguos).
- Nombrado Semántico: Las
- vistas se llaman HomePage,
- ContactPage para diferenciarlas
- de componentes pequeños.

#### Patterns
- El Patrón "Layout Wrapper": Instruir
- explícitamente a la IA para crear un
- componente "Layout" que contenga el
- Navbar y el Footer, y use un Outlet (o
- children) para el contenido. Evita repetir
- código en cada página.
- El Patrón "Route Map Definition": Antes
- de pedir código, definir el mapa del sitio
- en una lista. Esto ayuda al LLM a
- visualizar la totalidad del router main.jsx.
- El Patrón "Folder Structure Enforcement"
- :Los LLMs tienden a poner todo en la
- raíz. Hay que forzar la separación de
- conceptos.
- El Patrón "Link over Anchor": Instruir
- específicamente el uso del componente
- <Link> en lugar de etiquetas <a> para
- mantener el estado de SPA.

#### Anti-patterns
- El "Hard Refresh" Trap (La Trampa
- del <a>): Dejar que la IA use <a
- href="/contact">.
- El "Redundant Layout" (Copy-Paste):
- Pedir "Crea la página Home" y luego
- "Crea la página Contacto" por
- separado sin contexto.
- El "Monolithic App" : Dejar que la IA
- meta todo el código de las 3 vistas
- dentro de App.js usando renderizado
- condicional manual (if (page ===
- 'home')...).
- Ignorar el Build Error: Tratar de
- arreglar errores de compilación (Build
- Time) como si fueran de lógica
- (Runtime).

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 5 — Day 15
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto con IA: Replicar/Crear una website (multiples vistas: home, contact, about us,
etc)

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 16

### Content

Skill 12.2: Implementar interfaces interactivas con React + Next.js

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 16
**Status:** Approved

### Teoría

+ Props
    - Props más comunes
    - Prop 'Children'
+ Hook pattern
    - useState
    - useEffect
    - Custom hooks
+ Controlando los renderings (re renderizado)
    - Errores comunes:
        - Si se renderiza el padre, lo hará también el hijo
        - useEffect sin limitación de disparadores
+ Principales Hooks de Next.js
    - usePathname
    - useSearchParams
        - ¿Qué son las Query strings?
+ Organizando mi frontend
    - Modularización: ¿Qué es un módulo?
        - Por qué modularizar mi aplicación
    - Ejercicio donde se plantea una modal en la raíz de los componentes y en el que
debería crear una nueva modal, para que responda cómo reorganizaría los archivos y se
evalúe su respuesta
-- (la respuesta debería ser crear una carpeta "modals" con las variantes modal1 y
modal2)
- Referencia a las carpetas más importantes adicionales a la estructura de Next (como
libs, types, hooks, entre otras...)

### Thinking Framework

#### Thinking Development
- Saber identificar y aplicar propiedades a un
- componente.
- Saber modificar el renderizado (output) de un
- componente basado en variables.
- Entender y diseñar estados de los datos de los
- componentes y modificar el renderizado de
- componentes basado en estos estados.
- Identificar los efectos secundarios que
- produciran el cambio de los datos en el
- componente y sus dependencias para la
- renderizacion o comunicación de otros
- componentes

#### Best Practices
- Un useEffect, una acción
- Limitar los disparadores del
- useEffect
- 

#### Patterns
- CustomHooks para promover DRY (y
- siempre con return)
- Callback function props para ampliar la
- reutilizabilidad del componente
- Estados objeto para datos estructurados

#### Anti-patterns
- Prop Drilling
- Props maestros (configuración
- masiva en un prop)
- Repetir fetch entre componentes en
- lugar de usar un CustomHook

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 16
**Status:** Proyecto
pendiente
aprobación

### Content

Práctica:
- Juegos tipo Kahoot!

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 17

### Content

Skill 13: Entender la web architecture y el flujos de datos en ella

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 17
**Status:** Approved

### Teoría

+ ¿Cómo es el flujo de datos en una aplicación de React?
    - MVC: store, actions
    - LocalStorage vs SessionStorage
+ Dependencia de los datos:
    - ¿Cómo el useEffect se usa para controlar la dependencia de datos?
    - ¿Qué es lo mínimo que el componente necesita para renderizarse?
+ Promises
    - ¿Qué es una promesa? ¿Por qué es importante en el frontend?
    - Estados: pending, fulfilled (resolve), rejected (reject)
    - Gestión de promesas:
        - ¿Qué pasa si no llegan o llegan tarde los datos?
        - .then(...)
        - async / await
        - ¿Cuándo usar el Promise.all()?
    - Ejemplos de Promesas:
        - Obtener datos de una dirección web (Solo con GET)
        - Promesas en el manejo del LocalStorage
        - Validación dentro de promesas (condicionando los resolve y reject)
    - Introducción al error handling
        - .catch() (en Promise directas y fetch)
        - try - catch (en async / await)

### Thinking Framework

#### Thinking Development
- ¿cómo superar la pantalla blanca de error en la
- que no carga la vista?
- utilizando el network tab (DevTools) y
- entendiendo el flujo de los datos
- Comprender el funcionamiento e importancia de
- las promesas
- Gestionar adecuadamente las promesas
- (resueltas y rechazadas)
- Diferenciar la función del LocalStorage y el
- SessionStorage

#### Best Practices
- Promise.all para no encadenar
- múltiples async / await no
- relacionados entre sí

#### Patterns
- MVC
- Promise
- Async / Await
- One way data flow: Datos padre->hijo,
- Eventos hijo->padre
- Store solo modificado por función pura
- Actions de Store solo para acceder y
- modificar información del Store
- UI de tres estados: Pending:
- Spinner/Skeleton; Fulfilled: Datos;
- Rejected: Mensaje de error.

#### Anti-patterns
- Gestión de errores con if/else
- Emplear el LocalStorage para
- almacenar datos sensibles
- Optimismo ciego: asumir que
- siempre se resuelve la interfaz
- Gestionar errores dentro de la
- promesa en lugar de esperar a
- resolver la promesa.

#### Constraints & Limitations
- Llamadas a APIs solo con GET

## Week 6 — Day 18

### Content

Skill 14: Interacting with APIs

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 6 — Day 18
**Status:** Approved

### Teoría

+ Comunicarse con APIs externas:
    - ¿Qué son las APIs y cómo funcionan?
    - Métodos principales: GET, POST, PUT, PATCH, DELETE
    - Request:
        - Headers: Principalmente Content-Type y Authentication
        - Body (html encode, params raw)
        - Files (mención)
    - Response: No todo error es un crash.
        - Status Code
        - Body/data
    - Herramientas y Autenticación:
    - Postman
    - Autenticacion básica.
+ Stateless comunication: El servidor tiene amnesia
    - Hay que pasarle al endpoint toda la informacion que necesita, siempre, no hay
manera que el backend te avise algo hay que pedirselo
- Lo más parecido a un state se llama polling que es hacer request/peticion cada x
segundos

### Thinking Framework

#### Thinking Development
- Comprender cómo se comunican los distintos
- entornos (frontend,backend, base de datos)
- Identificar semanticamente qué tipo de petición
- se necesita (get, post, ...)
- Analizar la respuesta e identificar su cohorencia
- con la petición realizada.
- Aprender a usar herramientas: postman,
- network tab, etc.
- Realizar las peticiones basadas en el
- comprendimiento de "stateless comunication"
- Identificar las necesidades de la petición (text,
- json, files)
- Aprender a leer los payload, responses,
- headers, etc.

#### Best Practices
- Separar las llamadas a APIs
- fuera de las actions del Store.
- Custom hooks para gestionar
- las peticiones a APIs

#### Patterns
- Lectura de Códigos: 200, 300, etc.
- La Mochila Completa: Cada petición es
- un viaje nuevo. Debes llevar tu pasaporte
- (Token) y tu dirección (IDs) cada vez que
- sales.
- Headers Explícitos: Configurar siempre
- el Content-Type y el Authorization antes
- de enviar.

#### Anti-patterns
- "Ya te dije quién soy": Hacer el Login
- en la petición 1, y en la petición 2 no
- enviar el Token, esperando que el
- servidor recuerde la sesión anterior.
- El Header Olvidado: Enviar un
- JSON en el Body pero olvidar poner
- Content-Type: application/json. El
- servidor no sabe cómo leerlo y falla.

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 19

### Content

Skill 15: Managing errors

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 19
**Status:** Approved

### Content

Teoría:
+ Debugging:
    - Dev Tool: Evidencia sobre suposición.
        - Elements
        - Console
        - Network tab
        - React developer tools. (tal vez)
+ Error handling: La aplicación no debe explotar
    - Try/catch/finally
    - Prepararse para el peor escensario posible
        - Defaults
        - Renderizado condicional
        - Optional chainning
        - Fallbacks
    - Buenas prácticas
        - Ningún error debe romper la aplicación
        - Comunicar errores al usuario de forma adecuada (no entregar error técnico,
explicar qué puede hacer)

### Thinking Framework

#### Thinking Development
- Identificar el tipo de problema utilizar la
- herramienta adecuada.
- Reconocer los tipos de casos de uso más
- comunes que conllevan errores
- Saber gestionar adecuadamente los errores de
- código
- Comunicar el error o estado de la aplicación en
- términos adecuados según tipo el usuario.

#### Best Practices
- Limpiar el código de mensajes
- de debugging cuando se hace
- el pase a producción
- Evitar que un error rompa el
- flujo de la aplicación

#### Patterns
- UI de tres estados: Pending:
- Spinner/Skeleton; Fulfilled: Datos;
- Rejected: Mensaje de error.
- Breakpoints (Debugger)
- Prototipado en Browser: Modificar
- estilos directamente en la pestaña
- "Elements" para ver el resultado
- instantáneo y luego copiar al código.
- Autopsia de Petición: Abrir Network,
- filtrar por "Fetch/XHR", hacer clic en la
- petición roja y revisar las pestañas
- Payload (lo que envié) y Response (lo
- que me respondieron).
- Scope Específico: Usar try/catch
- específicamente donde ocurren
- operaciones peligrosas (llamadas a API,
- parseo de JSON, async/await).
- Bloque Finally: Usar finally { setLoading
- (false) } para asegurar que el spinner de
- carga desaparezca, tanto si tuvo éxito
- como si falló.
- Traducción Humana: Mostrar: "Lo
- sentimos, no pudimos cargar tus datos.
- Por favor revisa tu conexión e intenta de
- nuevo."
- Call to Action (CTA): Ofrecer una salida:
- Botón "Reintentar", "Volver al inicio" o
- "Contactar soporte".

#### Anti-patterns
- Console Driven Development: Llenar
- el código de console.log("entré"),
- console.log("aquí") y recargar la
- página 20 veces.
- CSS a ciegas: Cambiar el CSS en el
- editor de código, guardar, mirar,
- volver a cambiar. (Lento).En este
- caso, gasto de tokens inecesarios
- "No funciona": Decir que la API falló
- sin abrir la pestaña Network.
- Wrapping Gigante: Envolver toda la
- aplicación o funciones enormes en un
- solo try/catch.
- Mostrar al usuario: Error 500:
- Unexpected token < in JSON at
- position 0.
- Callejón sin salida: Mostrar un
- mensaje de error que solo dice
- "Error".
- Exponer datos sensibles debido a
- un proceso de depuración

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 20

### Content

Skill 17: Optimizar frontend para un mejor rendimiento

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 20
**Status:** Approved

### Teoría

+ Midiendo el desempeño del frontend (Core Web Vitals)
    - ¿Por qué es importante medir y optimizar el frontend?: No puedes mejorar lo que no
mides.
- Métricas principales: First Contentful Paint, Total Blocking Time, Largest
Contentful Paint
+ Estrategias de optimización del frontend:
    - Carga de Código (Code Splitting & Lazy Loading)
    - Rendimiento en Runtime (Memoization & SRP)
    - Principio de responsabilidad única (SRP)
    - Memoization
        - Hook useMemo
        - React.memo
    - Patrones de Reutilización: Custom Hooks vs. HOCs vs. Render Props
    - Cache memory: La petición más rápida es la que no se hace.

### Thinking Framework

#### Thinking Development
- Identificar qué componentes son reutilizables
- Identificar qué componentes necesita el usuario
- para interactuar (evitar carga innecesaria de
- componentes)
- Identificar qué lógica es reutilizable para
- convertir en un CustomHook
- Aprender a seperar "preocupaciones" para
- entender el alcance de SRP o evaluar qué tan
- pequeños seran los módulos (componentes)

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- Network Throttling: Usar las DevTools
- para simular "Fast 3G" y "CPU
- Slowdown". Optimizar para el dispositivo
- promedio, no el gama alta.
- Percepción de Usuario: Priorizar LCP
- (que se vea algo rápido) y TBT (que los
- botones funcionen). Si carga en 0.5s pero
- no clickea, el usuario se va.
- Route-Based Splitting: Lo primero que
- se debe dividir son las Rutas/Páginas. Si
- estoy en /home, no necesito cargar el
- código de /dashboard. Después, modales
- pesados o componentes muy abajo en el
- scroll.
- Componentes Grandes: Lazy load solo
- para cosas pesadas: Gráficos (Chart.js),
- Mapas, Editores de Texto, o Rutas
- completas.
- Usar useMemo solo para cálculos
- costosos.
- Custom Hooks: Usar hooks para
- compartir lógica (useAuth, useTheme). Es
- más limpio, no añade anidación al DOM y
- sigue el flujo natural de funciones.
- Stale-While-Revalidate: Usar librerías
- (TanStack Query, SWR) o caché de Next.
- js. Muestra los datos viejos
- instantáneamente mientras busca los
- nuevos en segundo plano.

#### Anti-patterns
- "En mi máquina funciona": Probar el
- rendimiento en una MacBook Pro con
- Fibra Óptica. Todo se ve rápido ahí.
- Lighthouse al 100%: Gastar 20
- horas para subir de 95 a 100 puntos
- en métricas que el usuario no nota.
- Micro-Splitting: Hacer lazy import de
- un botón o un ícono pequeño.
- Memoización por Defecto: Envolver
- const valor = a + b en useMemo.
- Wrapper Hell (HOCs): Envolver
- componentes en 5 capas: withRouter
- (withAuth(withTheme(Component))).
- Hace el árbol de React inleible en
- DevTools.
- Fetch en cada Click: Volver a pedir
- la lista de usuarios cada vez que
- vuelves a la pestaña "Usuarios".

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 20
**Status:** Proyecto
pendiente
aprobación

### Proyecto

- Generar una aplicación de frontend con V0 (de Vercel) o Stitch (de Google)
- Incorporarla al

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 21

### Content

Skill 16: Authentication flow

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 21
**Status:** Approved

### Teoría

+ Sesiones en el Frontend
    - ¿Qué es una sesión? ¿Para qué sirve?
    - Mecanismos vs. Almacenamiento: Diferencia entre el protocolo (CÓMO me identifico)
y la persistencia (DÓNDE guardo la credencial).
- Stateful o centralizada (Session IDs) vs. Stateless o descentralizada (JWT)
- Gestión de Tokens de sesión (El "Qué")
-- Anatomía del Header: "Authorization: Bearer <token>".
-- Formas de almacenamiento: LocalStorage.
+ Implementando el ciclo de vida de un usuario en sesión: La autenticación no es una
pantalla, es un sistema de estados.
- Protected Routes: ¿Cómo evitar que un usuario vea /dashboard si no tiene token?
- Creando sesiones (como sucede en el login)
- Persistencia de Sesión: Manejo de LocalStorage/SessionStorage vs. Cookies
(HttpOnly).
- Terminando la sesión (como en un logout): Limpieza de estado y redirección.
- ¿Qué hacer cuando el token expira?
-- Eliminar token
-- Redirigin a login

### Thinking Framework

#### Thinking Development
- Distinguir entre "el mecanismo" (ej: JWT) y el
- almacenamiento (LocalStorage/Cookies).
- Identificar el flujo de la autenticación que
- deseas manejar o cual se adapta mejor al
- requerimiento (forma de autenticar la cuenta del
- usuario o recuperar contraseña, etc.)

#### Best Practices
- Al dar feedback al usuario,
- evitar "dar información de más"
- por ejemplo: usuario no
- registrado o contraseña
- invalida, en vez de usuario o
- contraseña invalida.

#### Patterns
- Verificación Real: Intentar usar el token
- en una llamada a la API. Si devuelve 401,
- borrarlo y mandar al usuario al Login.
- Estándar Bearer: Respetar el prefijo:
- Authorization: Bearer <token>. ("Bearer"
- significa "Portador").
- "Flujo Primero": Definir el diagrama de
- estados: Unauth -> Login -> Auth ->
- Logout -> Expired.
- Protección de Rutas (Guards): Crear un
- componente <PrivateRoute> que
- verifique el token antes de renderizar la
- página, y redirija si no es válido.
- Hydration (Hidratación): Al iniciar la app
- (useEffect inicial), buscar si existe un
- token guardado y validarlo para restaurar
- la sesión automáticamente.
- Solo Tokens: En el storage del
- navegador solo se guarda el Token. Los
- datos sensibles se piden al servidor
- usando ese token.
- Token-Based: Usar Basic Auth solo una
- vez para obtener el Token, y luego usar el
- Token (Bearer) para todo lo demás.

#### Anti-patterns
- Fe Ciega: Asumir que si hay algo
- guardado en LocalStorage, el usuario
- está logueado. (Podría ser un token
- viejo o texto basura).
- Decode != Verify: Creer que
- decodificar un JWT en el frontend
- (jwt-decode) garantiza que es válido.
- "Pantalla Primero": Diseñar el Login
- visualmente sin saber dónde
- guardarás el token o cómo protegerás
- las rutas.
- Seguridad por Ocultación (UI): Solo
- ocultar el botón "Admin" con CSS
- (display: none). Si el usuario conoce
- la URL /admin, entra igual.
- Datos Sensibles: Guardar la
- contraseña o datos de tarjeta de
- crédito en el LocalStorage. (Es
- accesible por cualquier script
- malicioso - XSS).
- Uso en Producción: Enviar usuario y
- contraseña en cada petición (Basic
- Auth) sin HTTPS.
- No enviar datos sensibles en el
- payload del token

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 21
**Status:** Proyecto
pendiente
aprobación

### Content

Debe existir "un backend" para que el alumno pueda implemetar todo este contenido. El
backend debe tener una ruta que genere tokens y una que valide tokens. Incluir en el
payload la expiración.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 21
**Status:** Proyecto
pendiente
aprobación

### Content

BACKEND DEVELOPMENT

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 21

### Content

Skill 18.1: Coding in python as programming language in backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 21
**Status:** Approved

### Teoría

- (Mención a Skills 6 y 7)
+ Introducción al backend
    - ¿Qué es el backend?
        - ¿Cuál es el rol del backend?
        - Lenguajes de backend más utilizados
+ Intro to Python
    - ¿Qué es Python?
        - ¿Cómo funciona Python?
    - ¿Cómo se escribe código en Python?
        - ¿Qué es la sintaxis?
        - Reglas principales de la sintaxis de Python
    - Variables
+ Tipos de datos y operadores básicos de Python:
    - Tipos de Datos primitivos (int, float, bool, str, None)
    - Operadores en Python (aritméticos, asignación, comparación, lógicos)
+ Control de flujos en Python
    - Flujos simples: Condicionales (if, elif, else)
    - Flujos repetitivos: Bucles
    - for..in (con range, con listas de elementos clave-valor) y for en línea (List
Comprehensions)
- interruptores de flujo: break (para cortar la ejecución) y continue (para saltar
esta iteración)
- Bucles anidados
- Ciclos: for..in (con range, con listas de elementos clave-valor) y for en línea
(List Comprehensions)

### Thinking Framework

#### Thinking Development
- Aprender una nueva sintaxis asociando con un
- lenguaje ya aprendido.
- Convertir soluciones de pseudocódigo a la
- sintaxis del lenguaje.
- Aprender a investigar siempre que sea
- necesario. (memorizar no es una habilidad a
- desarrollar, se dará con la práctica)
- Identificar cuándo se hace uso de una palabra
- reservada.
- Aprender a identificar tipos de datos por su valor
- (su composicion).
- Comprender las diferencias de los tipos de
- datos
- Identificar los casos de uso de cada tipo de dato

#### Best Practices
- Escribe el codigo, no lo copies

#### Patterns
- snake_case para variables y funciones
- para definir clases: PascalCase
- Logs Etiquetados: print("El valor de x
- es:", x)
- Nombres Semánticos
- Identacion y " : " como indicador de
- bloques

#### Anti-patterns
- Buscar la sintaxis perfecta.
- Usar código mágico (copiar y pegar,
- no tener concimiento de lo que hace
- código)
- Inconsistencia en la sintaxis (no
- mantener decisiones anteriores en
- estructura, patrones, etc)
- Crear bucles infinitos
- Condiciones kilométricas
- Exceso de anidación de
- condicionales: if dentro de if dentro de
- if... formando una flecha a la derecha.

#### Constraints & Limitations
- No IA

## Week 8 — Day 21
**Status:** Proyecto
pendiente
aprobación

### Content

Ejercicios de JS que deban traducirse a Python.

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA

## Week 8 — Day 22

### Content

Skill 18.2: Escribir bloques de código con nombres (funciones)
Skill 19: Trabajar con tipos de datos estructurados de tipo listas y diccionarios

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 22
**Status:** Approved

### Teoría

- (Hacer mención a Skill 8.1)
+ Funciones Python
    - ¿Qué es un bloque de código?
    - Dar nombre a un bloque de código (creando una función)
    - Párametros (cómo pasar valores a una función)
    - Incluye breve referencia a *args y **kwargs
    - ¿Cómo devuelve valores una función? (funcionamiento del return y especificación del
tipo de dato devuelto)
- Métodos vs funciones vs procedimientos (funciones que devuelven valor y funciones
que no)
- Métodos y funciones para trabajar con datos primitivos (string, number, etc)
- funciones anónimas (lambdas)
+ Listas y diccionarios en Python
    - Listas (Array)
        - Iteradores más comunes: Map y Filter
    - Tuplas (Lista ordenada inmutable)
    - Conjuntos (Set - Listas no ordenadas sin duplicados)
    - Diccionarios
        - Notación corchete (nombre['atributo'])
        - Métodos útiles: get(), update(), defaultdict()

### Thinking Framework

#### Thinking Development
- "- Desarrollar un flujo si hay un objetivo solo, que
- son:
- Mutar un valor de un proceso global
- obtener un valor y retornarlo
- Reconocer los valores que necesita mi funcion
- para lograr su objetivo
- Reconocer el tipo de funcion que requiero
- Mantener el principio de responsabilidad única
- Comprender diferencia entre listas, duplas,
- conjuntos
- Definir y manipular una lista, dupla o conjunto
- Buscar elementos en una lista, dupla o conjunto
- Ordenar listas
- Identificar cuando existe un ""paso por
- referencia"" y cuando es un ""paso por valor""
- Construir y manipular diccionarios

#### Best Practices
- Aprender a gestionar listas
- con bucles y con métodos del
- lenguaje.
- No memorizar. Investiga cada
- que necesites usar un método
- Elegir un nombre adecuado en
- las funciones, el nombre debe
- ser descriptivo a lo quehace la
- misma

#### Patterns
- Homogeneidad en arrays/colección
- Iterar copia o Inversa

#### Anti-patterns
- El Cajón de Sastre: listas con varios
- tipos de datos.
- Mutación durante iteración
- Acceso: Usar lista[100] sin
- verificar el tamaño, devuelve error.
- Abuso de funciones lambda

#### Constraints & Limitations
- No IA

## Week 8 — Day 23

### Content

Skill 20: Anwsering front end user-triggered requests

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 8 — Day 23
**Status:** Approved

### Teoría

(Referencia a la Skill 13)
+ Introduction to FastAPI
    - ¿Qué es un framework?
    - ¿Por qué es importante un framework para construir una API?
    - ¿Qué es FastAPI?
    - Elementos principales de FastAPI (estructura base, endpoints, ApiRouter, modelos)
    - Instalando FastAPI
        - ¿Qué es un virtual env?
        - ¿Qué es Pipenv?
        - pipenv vs. pip + venv
+ Building a Python API to serve the frontend
    - ¿Qué es una API? (refrescamiento de conocimientos)
    - ¿Qué es un endpoint? ¿Para qué sirven?
    - Construyendo los endpoints que necesita el frontend
        - ¿Qué significa CRUD?
        - Trabajando con llamadas GET, POST, PATCH/PUT, DELETE (sin almacenamiento)
    - ¿Por qué es fundamental realizar validaciones en todos los endpoints?
    - Serializando la respuesta como la quiere el frontend
    - Documentación con FastAPI

### Thinking Framework

#### Thinking Development
- Las APIs se prueban con tests y clientes HTTP
- (Postman, Insomnia...) no con frontend
- Asociar métodos HTTP con acciones concretas
- de un endpoint
- Comprender que el backend no persiste datos.
- Entender las necesidades del frontend para dar
- respuestas acordes
- Validar la documentación generada por FastAPI
- la documentación se genera sola si usas bien
- los tipos Pydantic.
- FastAPI usa Pydantic para validar que los datos
- sean correctos antes de que entren a tu función.
- Recursos (Sustantivos): POST /users, GET
- /users. La URL define qué es, el método define
- qué haces.

#### Best Practices
- Acompañar un código HTTP
- con un mensaje siempre que se
- considere necesario y útil.

#### Patterns
- Endpoints con métodos HTTP
- específicos (no generalistas)
- Serializar las respuestas de los
- endpoints
- Principio de única responsabilidad
- (single-responsibility, S en SOLID)
- Siempre responder con el código HTTP
- correcto
- Un endpoint, una responsabilidad
- Apalancamiento: Usar FastAPI para lo
- que es bueno: Validación de datos,
- Enrutamiento y Generación de
- documentación automática.
- Python Moderno (Type Hints)
- Recursos (Sustantivos): POST /users,
- GET /users.
- Consistencia de recursos: mantener el
- sustantivo de recurso, una vez definido
- para todos sus metodos http.
- Mapping / Alias: Configurar Pydantic
- para que acepte/envíe camelCase
- (JSON) pero tu código Python use
- snake_case. O acordar un estándar
- único.

#### Anti-patterns
- Reinventar la Rueda: Intentar
- parsear el JSON del body
- manualmente o escribir un servidor
- de sockets desde cero "para
- aprender".

#### Constraints & Limitations
- Sin BD

## Week 9 — Day 24

### Content

Skill 21: Almacenar información desde el backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 24
**Status:** Approved

### Teoría

+ Trabajar con ficheros en Python
    - ¿Qué es un archivo? Datos persistentes en disco.
        - Codificación de archivos (encoding, utf-8 por defecto)
        - Rutas (path) absolutas y relativas
    - Abrir y leer archivos
    - Crear y escribir en archivos
    - ¿Qué es un archivo CSV?
        - Crear una lista de diccionarios a raíz de un CSV
        - Volcar una lista de diccionarios en un CSV

### Thinking Framework

#### Thinking Development
- Saber alimentar un listado de datos
- estructurados desde un archivo CSV
- Saber volcar un listado de datos estructurados a
- un archivo CSV

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- with open(...): siempre
- encoding="utf-8" explícito
- Validar exists() antes de leer si aplica
- Procesar en streaming para grandes

#### Anti-patterns
- open() sin with (archivos “colgados”)
- Usar w sin querer (pierdes datos)
- Meter texto libre sin \n (salida
- pegada)
- readlines() en archivos grandes

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 24
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyectos:
+ Importador simple:
1. Lee students.csv
2. Genera report.json con:
- total estudiantes
- promedio score
- top 3 scores
- lista de errores (filas mal formadas)"
+ Exportador simple
1. Obtiene un listado de productos a partir de una BD
- nombre, marca, código, precio, unidades disponibles
2. Generar un CSV para exportar

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 25

### Content

Skill 27: Alimentar datos estructurados a partir de archivos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 11 — Day 25
**Status:** Approved

### Teoría

+ Almacenando información para el frontend (en cualquier lugar)
    - ¿Qué es una base de datos? Como concepto general
    - ¿Por qué es necesario el almacenamiento de datos?
    - Cómo guardar datos de forma simple con TinyDB y el método .save()
        - Usando TinyDB como base de datos de rápida implementación (No queremos dar SQL
todavía, pero si poder persistir datos en una BD)
-- insert, search, delete, update
- Cargando datos iniciales en mi aplicación
-- Cómo crear un seeder bastante simple
-- Ejecutar seeders con pipenv run

### Thinking Framework

#### Thinking Development
- When teaching TinyDB, pair it with Pydantic as a
- lightweight schema/DTO layer to validate,
- serialize, and document data shapes, while
- TinyDB handles persistence of plain dictionaries.
- Generar datos iniciales "reales" en la base
- datos para realizar pruebas en la aplicación

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
- Uso del .save()
- Aplicar persistencia en aplicaciones

#### Anti-patterns
- Almacenar información sin orden
- Almacenar información sin validar o
- verificar
- Hacer múltiples consultas del mismo
- recurso porque lo necesito de nuevo.

#### Constraints & Limitations
- No queremos dar SQL todavia, pero si
- poder persistir datos en una BD

## Week 11 — Day 25
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto:

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 26

### Content

Skill 22: Autenticar en el backend

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 26
**Status:** Approved

### Teoría

+ Autenticación
    - ¿Qué es la autenticación y por qué es importante?
        - Resaltar la importancia de encriptar una contraseña
    - Autenticación vs. Autorización
    - Tipos de autenticación más conocidas
        - Basic Auth: El abuelo (Usuario + Password en base64).
        - Token-Based (JWT): El estándar actual. Estructura (Header, Payload, Signature).
        - OAuth (Mención): "Entrar con Google/GitHub" (Delegación de identidad).
        - Passwordless: Conocidos como Magic Links o Token Url
    - ¿Qué es la autenticación multifactor (MFA): Una breve referencia informativa
+ Seguridad de contraseñas en backend: Protegiendo las cuentas de nuestros usuarios
    - Cuáles son los requisitos mínimos actuales para que una contraseña sea segura (12
caracteres: letras, números y símbolos)
-- ¿Por qué es peligroso guardar las contraseñas en texto plano?
- ¿Qué es el cifrado de contraseñas?
-- Hash y Salting (Nunca guardar texto plano)
-- Algoritmos de cifrado más seguros actualmente
-- Algoritmos de cifrado desaconsejados por inseguros
- Cómo cifrar una contraseña en Python
+ Autenticando con JWT
    - ¿Cómo funciona la autenticación por JWT?
    - ¿Cómo está estructurado el token de JWT? (Header, Payload, Firma)
    - Flujo de los datos en una autenticación por JWT
        - Solicitudes y respuestas
        - Alternativas de almacenamiento en frontend (LocalStorage, SessionStorage,
Cookies seguras - HttpOnly)
- Revocación:
-- Limpieza de tokens: Cierre o reinicio de la sesión de forma manual
-- Expiración: Tiempo máximo de validez del token
- Prácticas seguras:
-- No introducir datos sensibles en el payload del token
-- Mantener la SECRET_KEY en ENV VARS, no en el código ni en el repositorio
- Cómo implementar un flujo de autenticación con JWT + FastAPI + Contraseñas Cifradas
+ TinyDB

### Thinking Framework

#### Thinking Development
- Saber diferenciar entre autenticación y
- autorización
- Conocer los principales tipos de autenticación
- Concientizar sobre la importancia de una
- autenticación segura
- Implementar una autenticación con JWT
- Concientizar sobre la importancia de almacenar
- las contraseñas cifradas

#### Best Practices
- Almacenamiento en el Cliente
- Establecer una expiración
- (Exp)
- Claves Secretas en ENV
- VARS: Mantén la
- SECRET_KEY segura y no la
- expongas en el frontend.
- Validación en el Servidor

#### Patterns
- JWT
- Contraseñas cifradas
- Rutas protegidas

#### Anti-patterns
- Introducir datos sensibles en
- Payload: contraseñas, tokens de
- sesión, o cualquier dato que no deba
- ser público.

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 27

### Content

Skill 15: Managing errors

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 7 — Day 27
**Status:** Approved

### Content

Teoría:
+ Error handling: La aplicación no debe explotar
    - Try/catch/finally
    - Prepararse para el peor escenario posible
        - Defaults
        - Renderizado condicional
        - Optional chainning
        - Fallbacks
    - Buenas prácticas
        - Ningún error debe romper la aplicación
        - Comunicar errores al usuario de forma adecuada (no entregar error técnico,
explicar qué puede hacer)

### Thinking Framework

#### Thinking Development
- Identificar el tipo de problema utilizar la
- herramienta adecuada.
- Reconocer los tipos de casos de uso más
- comunes que conllevan errores
- Saber gestionar adecuadamente los errores de
- código
- Comunicar el error o estado de la aplicación en
- términos adecuados según tipo el usuario.

#### Best Practices
- Limpiar el código de mensajes
- de debugging cuando se hace
- el pase a producción
- Evitar que un error rompa el
- flujo de la aplicación

#### Patterns
- UI de tres estados: Pending:
- Spinner/Skeleton; Fulfilled: Datos;
- Rejected: Mensaje de error.
- Breakpoints (Debugger)
- Prototipado en Browser: Modificar
- estilos directamente en la pestaña
- "Elements" para ver el resultado
- instantáneo y luego copiar al código.
- Autopsia de Petición: Abrir Network,
- filtrar por "Fetch/XHR", hacer clic en la
- petición roja y revisar las pestañas
- Payload (lo que envié) y Response (lo
- que me respondieron).
- Scope Específico: Usar try/catch
- específicamente donde ocurren
- operaciones peligrosas (llamadas a API,
- parseo de JSON, async/await).
- Bloque Finally: Usar finally { setLoading
- (false) } para asegurar que el spinner de
- carga desaparezca, tanto si tuvo éxito
- como si falló.
- Traducción Humana: Mostrar: "Lo
- sentimos, no pudimos cargar tus datos.
- Por favor revisa tu conexión e intenta de
- nuevo."
- Call to Action (CTA): Ofrecer una salida:
- Botón "Reintentar", "Volver al inicio" o
- "Contactar soporte".

#### Anti-patterns
- Console Driven Development: Llenar
- el código de console.log("entré"),
- console.log("aquí") y recargar la
- página 20 veces.
- CSS a ciegas: Cambiar el CSS en el
- editor de código, guardar, mirar,
- volver a cambiar. (Lento).En este
- caso, gasto de tokens inecesarios
- "No funciona": Decir que la API falló
- sin abrir la pestaña Network.
- Wrapping Gigante: Envolver toda la
- aplicación o funciones enormes en un
- solo try/catch.
- Mostrar al usuario: Error 500:
- Unexpected token < in JSON at
- position 0.
- Callejón sin salida: Mostrar un
- mensaje de error que solo dice
- "Error".
- Exponer datos sensibles debido a
- un proceso de depuración

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27

### Content

Skill 23: Implementar pruebas unitarias para validar endpoints

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27
**Status:** Approved

### Teoría

+ Introducción al testing
    - ¿Por qué probar un código?
    - Tipos de pruebas más conocidas:
        - Pruebas unitarias (donde estará el foco del contenido)
        - Pruebas funcionales (Introducción referencial)
        - Pruebas de integración (Introducción referencial)
        - Pruebas de rendimiento (Introducción referencial)
    - Introducción al TDD (Test-Driven-Development)
+ Unit testing with FastAPI:
    - Frameworks de testing más conocidos: unittest, pytest, doctest
    - Pruebas unitarias en FastAPI
        - Prueba sobre la lógica del endpoint no sobre su serialización
    - Planificación de pruebas unitarias

### Thinking Framework

#### Thinking Development
- Reconocer la importancia de las pruebas
- unitarias como verificación adicional para la
- consistencia y robustez de una aplicación
- Comprender el valor de un desarrollo orientado
- a pruebas, más allá de aplicación en trabajos
- reales
- Saber implementar pruebas unitarias en
- backend
- Entender cómo funcionan las pruebas unitarias

#### Best Practices
- Hacer pruebas de error
- (probar cómo reacciona cuando
- el resultado es erróneo)

#### Patterns
- Test Driven Development
- Identificar los casos límite y los casos
- más representativos

#### Anti-patterns
- Sobregeneración de pruebas
- Probar solo el resultado esperado

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 9 — Day 27
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto: Al proyecto de autenticación en la API, agregarle las pruebas unitarias de
sus endpoints
1. Plantear el problema a la IA e identificar los casos de estudio, los casos límite y
aspectos a tener en cuenta
2. Generar las pruebas unitarias para los distintos endpoints según sus casos de uso y
casos límite
3. Verificar que todas las pruebas se ejecutan correctamente y que el código funciona
adecuadamente.
+ Actividad extra:
    - Revisar todos los proyectos de backend anteriores y aplicar pruebas unitarias

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 28

### Content

Skill 24.1: Consultar tablas y gestionar filas en bases de datos

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 28
**Status:** Approved

### Teoría

+ Bases de datos (solo informativo)
    - ¿Qué es una base de datos?
    - ¿Para qué sirven las bases de datos?
    - Tipos de bases de datos más comunes
        - Relacionales (SQL: Postgres, MariaDB/MySQL, SQL Server)
        - Documentales (TinyDB, SQLite, MongoDB)
        - Clave-Valor (Redis)
        - Otros tipos de BB.DD.: Mención rápida a Grafos (para relaciones complejas) y
Columnares (Cassandra)
+ Consultando bases de datos con SQL en PostgreSQL (Fundamentos de SQL)
    - ¿Qué es SQL y para qué se usa?
    - ¿Cómo funcionan las tablas relacionales? (Tablas, filas y columnas)
    - Identificadores primarios (Primary key)
    - Números autoincrementales
    - Tipos de valores
        - numéricos
        - texto
        - booleanos
        - fechas y horas
    - CRUD básico: SELECT, INSERT, UPDATE, DELETE
        - ¿Por qué pedir columnas específicas en lugar de usar * en el SELECT?
        - ¿Qué es un soft-delete? ¿Cuándo usar una columna para soft-delete en lugar de
ejecutar un DELETE?
- Filtrado: WHERE
-- Operadores matemáticos (=, !=, <, >, <=, >=)
-- Operadores lógicos (AND, OR, NOT)
-- Operadores de rango (IN, BETWEEN)
-- Operadores de texto (LIKE, ILIKE)
- Ordenamiento y limitación: ORDER BY y LIMIT
- Agregación:
-- GROUP BY
-- COUNT, SUM, AVG, MIN, MAX, DISTINCT
-- HAVING (al menos conceptual)
- NULL (como concepto)
-- ¿qué significa NULL en bases de datos?
-- por qué = no funciona con NULL
-- impacto en agregaciones
-- Operador vacío (IS NULL)
+ Utilizando PostgreSQL en remoto con Supabase
    - ¿Qué es Supabase? (Orientado a BD en remoto)
    - ¿Cómo gestionar una BD en Supabase?
    - ¿Cómo ejecutar sentencias SQL en una BD de Supabase?

### Thinking Framework

#### Thinking Development
- Comprender formalmente el concepto de base
- de datos
- Conocer los tipos de bases de datos más
- populares y sus principales representantes
- Saber estructurar una consulta SQL
- Aprender a realizar los principales tipos de
- consultas SQL
- Saber representar en bases de datos las
- relaciones entre objetos como tablas
- relacionadas

#### Best Practices
- nombres de tablas en plural

#### Patterns
- Atomicidad: Una celda = Un valor. Si
- hay muchas tallas, o son muchas filas o
- es otra tabla relacionada.
- Tipado Estricto: Entender que si la
- columna dice INTEGER, nadie puede
- escribir "Hola" ahí. La rigidez es una
- virtud, no un defecto.
- Modo Seguro: Primero haz un SELECT
- * FROM usuarios WHERE id = 5. Si
- devuelve lo que esperas, cambia el
- SELECT * por DELETE.
- Proyección Explícita: Pedir solo las
- columnas que se necesitan.

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
- No IA para la generación de Consultas S

## Week 10 — Day 28
**Status:** Proyecto
pendiente
aprobación

### Content

> Proyecto en clases:
Se provee un SQL que poble una BD con un conjunto de datos para que se busquen filtren
filas y se extraigan ciertos datos.
Luego, al estilo de CMD Challenge, deberán borrar una fila en específico, actualizar
otra...

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29

### Content

Skill 24.2: Consultar tablas relacionadas con SQL

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29
**Status:** Approved

### Teoría

+ Gestionando tablas relacionadas con SQL
    - ¿Qué es una relación en bases de datos?
    - ¿Qué es un diagrama entidad/relación?
        - Representar elementos de la vida real y sus relaciones como tablas en un
diagrama E/R
- Relaciones entre tablas
-- Identificadores foráneos (foreign keys)
-- Relaciones 1:1, 1:n, n:m
- ¿Qué es una tabla pivote?
- Cómo obtener construir un resultado con dos tablas relacionadas
-- INNER JOIN
-- LEFT/RIGHT JOIN
-- OUTER JOIN
- Qué es la normalización y por qué es aconsejable
- (Solo informativo) ¿Cómo funciona un borrado en cascada?

### Thinking Framework

#### Thinking Development
- Comprender cómo se relacionan las tablas de
- una base de datos a través de una Foreign Key
- Entender la diferencia entre los tipos de JOIN y
- cuándo son útiles
- Crear consultas SQL que relacionen tablas
- usando JOIN
- Entender cómo funciona un borrado en cascada

#### Best Practices
- foreing key formato
- `nombre_tabla_id`

#### Patterns
- Normalización
- Foreign keys para relacionar dos tablas
- Borrado en cascada para evitar datos
- huérfanos

#### Anti-patterns
- Usar columnas de tipo texto con
- múltiples valores en lugar de una
- tabla pivote

#### Constraints & Limitations
_Not introduced in this learnpack_

## Week 10 — Day 29
**Status:** Proyecto
pendiente
aprobación

### Content

> Práctica: Ejercicios de modelados con diagram.4geeks.com
> Proyecto en clases:
Se provee un SQL que poble una BD con diversas tablas relacionadas entre sí con un
conjunto de datos para trabajar con ellas

### Thinking Framework

#### Thinking Development
_Not introduced in this learnpack_

#### Best Practices
_Not introduced in this learnpack_

#### Patterns
_Not introduced in this learnpack_

#### Anti-patterns
_Not introduced in this learnpack_

#### Constraints & Limitations
_Not introduced in this learnpack_
